"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const path = require("path");
const fs = require("fs-extra");
const inquirer = require("inquirer");
const yargs = require("yargs");
const common_1 = require("../../common");
const inventory = require("../../inventory");
const logging = require("../../logging");
const util_1 = require("../../util");
const macros_1 = require("../macros");
const synth_1 = require("../synth");
class Command {
    constructor() {
        this.command = 'new [PROJECT-TYPE] [OPTIONS]';
        this.describe = 'Creates a new projen project';
    }
    builder(args) {
        var _a;
        args.positional('PROJECT-TYPE', { describe: 'optional only when --from is used and there is a single project type in the external module', type: 'string' });
        args.option('synth', { type: 'boolean', default: true, desc: 'Synthesize after creating .projenrc.js' });
        args.option('comments', { type: 'boolean', default: true, desc: 'Include commented out options in .projenrc.js (use --no-comments to disable)' });
        args.option('from', { type: 'string', alias: 'f', desc: 'External jsii npm module to create project from. Supports any package spec supported by yarn (such as "my-pack@^2.0")' });
        args.example('projen new awscdk-app-ts', 'Creates a new project of built-in type "awscdk-app-ts"');
        args.example('projen new --from projen-vue@^2', 'Creates a new project from an external module "projen-vue" with the specified version');
        for (const type of inventory.discover()) {
            args.command(type.pjid, (_a = type.docs) !== null && _a !== void 0 ? _a : '', {
                builder: cargs => {
                    var _a, _b, _c;
                    cargs.showHelpOnFail(true);
                    for (const option of (_a = type.options) !== null && _a !== void 0 ? _a : []) {
                        if (option.type !== 'string' && option.type !== 'number' && option.type !== 'boolean') {
                            continue; // we don't support non-primitive fields as command line options
                        }
                        let desc = [(_c = (_b = option.docs) === null || _b === void 0 ? void 0 : _b.replace(/\ *\.$/, '')) !== null && _c !== void 0 ? _c : ''];
                        const required = !option.optional;
                        let defaultValue;
                        if (option.default && option.default !== 'undefined') {
                            if (!required) {
                                // if the field is not required, just describe the default but don't actually assign a value
                                desc.push(`[default: ${option.default.replace(/^\ *-/, '').replace(/\.$/, '').trim()}]`);
                            }
                            else {
                                // if the field is required and we have a @default, then assign
                                // the value here so it appears in `--help`
                                defaultValue = renderDefault(option.default);
                            }
                        }
                        cargs.option(option.switch, {
                            group: required ? 'Required:' : 'Optional:',
                            type: option.type,
                            description: desc.join(' '),
                            default: defaultValue,
                            required,
                        });
                    }
                    return cargs;
                },
                handler: argv => newProject(process.cwd(), type, argv),
            });
        }
        return args;
    }
    async handler(args) {
        // handle --from which means we want to first install a jsii module and then
        // create a project defined within this module.
        if (args.from) {
            return newProjectFromModule(process.cwd(), args.from, args);
        }
        // project type is defined but was not matched by yargs, so print the list of supported types
        if (args.projectType) {
            console.log(`Invalid project type ${args.projectType}. Supported types:`);
            for (const pjid of inventory.discover().map(x => x.pjid)) {
                console.log(`  ${pjid}`);
            }
            return;
        }
        // Handles the use case that nothing was specified since PROJECT-TYPE is now an optional positional parameter
        yargs.showHelp();
    }
}
/**
 *
 * @param baseDir Base directory for reading and writing files
 * @param type Project type
 * @param params Object with parameter default values. Values should be strings
 * @param comments Whether to include optional parameters in commented out form
 */
function generateProjenConfig(baseDir, type, params, comments) {
    const configPath = path.join(baseDir, common_1.PROJEN_RC);
    if (fs.existsSync(configPath)) {
        logging.error(`Directory ${baseDir} already contains ${common_1.PROJEN_RC}`);
        process.exit(1);
    }
    const [importName] = type.typename.split('.');
    const lines = [
        `const { ${importName} } = require('${type.moduleName}');`,
        '',
        `const project = new ${type.typename}(${renderParams(type, params, comments)});`,
        '',
        'project.synth();',
        '',
    ];
    fs.writeFileSync(configPath, lines.join('\n'));
    logging.info(`Created ${common_1.PROJEN_RC} for ${type.typename}`);
}
function makePadding(paddingLength) {
    return ' '.repeat(paddingLength);
}
/**
 * Prints all parameters that can be used in a project type, alongside their descriptions.
 *
 * Parameters in `params` that aren't undefined are rendered as defaults,
 * while all other parameters are rendered as commented out.
 *
 * @param type Project type
 * @param params Object with parameter default values
 * @param comments Whether to include optional parameters in commented out form
 */
function renderParams(type, params, comments) {
    var _a, _b, _c;
    // preprocessing
    const renders = {};
    const optionsWithDefaults = [];
    const optionsByModule = {}; // only options without defaults
    for (const option of type.options) {
        if (option.deprecated) {
            continue;
        }
        const optionName = option.name;
        let paramRender;
        if (params[optionName] !== undefined) {
            paramRender = `${optionName}: ${params[optionName]},`;
            optionsWithDefaults.push(optionName);
        }
        else {
            const defaultValue = ((_a = option.default) === null || _a === void 0 ? void 0 : _a.startsWith('-')) ? undefined : ((_b = option.default) !== null && _b !== void 0 ? _b : undefined);
            paramRender = `// ${optionName}: ${defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.replace(/"(.+)"/, '\'$1\'')},`; // single quotes
            const parentModule = option.parent;
            optionsByModule[parentModule] = (_c = optionsByModule[parentModule]) !== null && _c !== void 0 ? _c : [];
            optionsByModule[parentModule].push(option);
        }
        renders[optionName] = paramRender;
    }
    // alphabetize
    const marginSize = Math.max(...Object.values(renders).map(str => str.length));
    optionsWithDefaults.sort();
    for (const parentModule in optionsByModule) {
        optionsByModule[parentModule].sort((o1, o2) => o1.name.localeCompare(o2.name));
    }
    // generate rendering
    const tab = makePadding(2);
    const result = [];
    result.push('{');
    // render options with defaults
    for (const optionName of optionsWithDefaults) {
        result.push(`${tab}${renders[optionName]}`);
    }
    if (result.length > 1) {
        result.push('');
    }
    // render options without defaults
    if (comments) {
        for (const [moduleName, options] of Object.entries(optionsByModule).sort()) {
            result.push(`${tab}/* ${moduleName} */`);
            for (const option of options) {
                const paramRender = renders[option.name];
                result.push(`${tab}${paramRender}${makePadding(marginSize - paramRender.length + 2)}/* ${option.docs} */`);
            }
            result.push('');
        }
    }
    if (result[result.length - 1] === '') {
        result.pop();
    }
    result.push('}');
    return result.join('\n');
}
/**
 * Given a value from "@default", processes macros and returns a stringied
 * (quoted) result.
 *
 * @returns a javascript primitive (could be a string, number or boolean)
 */
function renderDefault(value) {
    var _a;
    return (_a = macros_1.tryProcessMacro(value)) !== null && _a !== void 0 ? _a : JSON.parse(value);
}
/**
 * Converts yargs command line switches to project type props.
 * @param type Project type
 * @param argv Command line switches
 */
function commandLineToProps(type, argv) {
    var _a;
    const props = {};
    // initialize props with default values
    for (const prop of type.options) {
        if (prop.default && prop.default !== 'undefined' && !prop.optional) {
            props[prop.name] = renderDefault(prop.default);
        }
    }
    for (const [arg, value] of Object.entries(argv)) {
        for (const prop of type.options) {
            if (prop.switch === arg) {
                let curr = props;
                const queue = [...prop.path];
                while (true) {
                    const p = queue.shift();
                    if (!p) {
                        break;
                    }
                    if (queue.length === 0) {
                        let val = value;
                        // if this is a string, then single quote it
                        if (val && typeof (val) === 'string') {
                            val = JSON.stringify(val).replace(/"(.+)"/, '\'$1\'');
                        }
                        curr[p] = val;
                    }
                    else {
                        curr[p] = (_a = curr[p]) !== null && _a !== void 0 ? _a : {};
                        curr = curr[p];
                    }
                }
            }
        }
    }
    return props;
}
/**
 * Generates a new project from an external module.
 *
 * @param spec The name of the external module to load
 * @param args Command line arguments (incl. project type)
 */
async function newProjectFromModule(baseDir, spec, args) {
    const specDependencyInfo = yarnAdd(baseDir, spec);
    // collect projects by looking up all .jsii modules in `node_modules`.
    const modulesDir = path.join(baseDir, 'node_modules');
    const modules = fs.readdirSync(modulesDir).map(file => path.join(modulesDir, file));
    const projects = inventory
        .discover(...modules)
        .filter(x => x.moduleName !== 'projen'); // filter built-in project types
    if (projects.length < 1) {
        throw new Error(`No projects found after installing ${spec}. The module must export at least one class which extends projen.Project`);
    }
    const requested = args.projectType;
    const types = projects.map(p => p.pjid);
    // if user did not specify a project type but the module has more than one, we need them to tell us which one...
    if (!requested && projects.length > 1) {
        throw new Error(`Multiple projects found after installing ${spec}: ${types.join(',')}. Please specify a project name.\nExample: npx projen new --from ${spec} ${types[0]}`);
    }
    // if user did not specify a type (and we know we have only one), the select it. otherwise, search by pjid.
    const type = !requested ? projects[0] : projects.find(p => p.pjid === requested);
    if (!type) {
        throw new Error(`Project type ${requested} not found. Found ${types.join(',')}`);
    }
    // include a dev dependency for the external module
    await newProject(baseDir, type, args, {
        devDeps: JSON.stringify([specDependencyInfo]),
    });
}
/**
 * Generates a new project.
 * @param type Project type
 * @param args Command line arguments
 * @param additionalProps Additional parameters to include in .projenrc.js
 */
async function newProject(baseDir, type, args, additionalProps) {
    // convert command line arguments to project props using type information
    const props = commandLineToProps(type, args);
    // merge in additional props if specified
    for (const [k, v] of Object.entries(additionalProps !== null && additionalProps !== void 0 ? additionalProps : {})) {
        props[k] = v;
    }
    // generate .projenrc.js
    generateProjenConfig(baseDir, type, props, args.comments);
    // interactive git and github setup
    const gitFolder = path.resolve('.git');
    let pushInitialToGithub = false;
    if (!fs.existsSync(gitFolder)) {
        pushInitialToGithub = await askAboutGit();
    }
    // synthesize if synth is enabled (default).
    if (args.synth) {
        process.env.PROJEN_DISABLE_POST = (!args.post).toString();
        await synth_1.synth();
    }
    if (pushInitialToGithub) {
        util_1.exec('git add .');
        util_1.exec('git commit -m \'Initial commit generated by projen\'');
        util_1.exec('git branch -M main');
        util_1.exec('git push --set-upstream origin main');
    }
}
/**
 * Installs the npm module (through `yarn add`) to node_modules under `projectDir`.
 * @param spec The npm package spec (e.g. foo@^1.2)
 * @returns String info for the project devDeps (e.g. foo@^1.2 or foo@/var/folders/8k/qcw0ls5pv_ph0000gn/T/projen-RYurCw/pkg.tgz)
 */
function yarnAdd(baseDir, spec) {
    const packageJsonPath = path.join(baseDir, 'package.json');
    const packageJsonExisted = fs.existsSync(packageJsonPath);
    let dependencyInfo = spec;
    // workaround: yarn fails to extract tgz if it contains '@' in the name, so we
    // create a temp copy called pkg.tgz and install from there.
    // see: https://github.com/yarnpkg/yarn/issues/6339
    if (spec.endsWith('.tgz') && spec.includes('@')) {
        // if user passes in a file spec then we have to specify the project name and the package location
        // (e.g foo@/var/folders/8k/qcw0ls5pv_ph0000gn/T/projen-RYurCw/pkg.tgz)
        const moduleName = spec.split('/').slice(-1)[0].trim().split('@')[0].trim(); // Example: ./cdk-project/dist/js/cdk-project@1.0.0.jsii.tgz
        const tmpdir = fs.mkdtempSync(path.join(os.tmpdir(), 'projen-'));
        const copy = path.join(tmpdir, 'pkg.tgz');
        fs.copyFileSync(spec, copy);
        spec = copy;
        dependencyInfo = `${moduleName}@${spec}`;
    }
    logging.info(`installing external module ${spec}...`);
    util_1.exec(`yarn add --modules-folder=${baseDir}/node_modules --silent --no-lockfile --dev ${spec}`, { cwd: baseDir });
    // if package.json did not exist before calling yarn add, we should remove it
    // so we can start off clean.
    if (!packageJsonExisted) {
        fs.removeSync(packageJsonPath);
    }
    return dependencyInfo;
}
async function askAboutGit() {
    logging.info('We notice that you do not have a local git repository.');
    const { setUpGit } = await inquirer.prompt([
        {
            type: 'confirm',
            name: 'setUpGit',
            message: 'Do you want to set that up now?',
        },
    ]);
    if (setUpGit) {
        const { plan } = await inquirer.prompt(githubPlanOptions);
        const { gh, git } = plan;
        if (!git && !gh) {
            util_1.exec('git init');
            logging.info('Ok, we\'ve \'git init\'d for you! Have a great day.');
        }
        if (git) {
            const { gitRepoURL } = await inquirer.prompt([
                {
                    type: 'input',
                    name: 'gitRepoURL',
                    message: 'What is the repo? (example: https://github.com/projen/projen)',
                },
            ]);
            util_1.exec('git init');
            let formattedGitRepoURL = gitRepoURL;
            if (!gitRepoURL.includes('https')) {
                formattedGitRepoURL = `https://github.com/${gitRepoURL}`;
            }
            util_1.exec(`git remote add origin ${formattedGitRepoURL}`);
            logging.info(`Great! We've 'git init'd for you and set the remote to ${formattedGitRepoURL}`);
        }
        if (!git && gh) {
            logging.info('Ok! We will make you a repository on GitHub.');
            const ghCLIPath = util_1.execOrUndefined(`${os.platform() === 'win32' ? 'where' : 'which'} gh`);
            if (!ghCLIPath) {
                logging.warn('Looks like you do not have the GitHub CLI installed. Please go to https://cli.github.com/ to install and try again.');
            }
            else {
                const { gitProjectName } = await inquirer.prompt([
                    {
                        type: 'input',
                        name: 'gitProjectName',
                        message: 'What would you like to name it?',
                        default: path.basename(path.dirname(process.cwd())),
                    },
                ]);
                logging.info(`Wow! ${gitProjectName} is such a great name!`);
                util_1.exec('git init');
                util_1.exec(`gh repo create ${gitProjectName}`);
                return true;
            }
        }
    }
    return false;
}
const githubPlanOptions = [
    {
        type: 'list',
        name: 'plan',
        message: 'We\'ll need some more info. Please choose one:',
        choices: [
            {
                value: {
                    git: true,
                },
                name: 'I already have a git repository',
            },
            {
                value: {
                    gh: true,
                    git: false,
                },
                name: 'I don\'t have a git repository and want to make one on GitHub',
            },
            {
                value: {
                    gh: false,
                    git: false,
                },
                name: 'I don\'t have a git repository and I don\'t want to use GitHub',
            },
        ],
    },
];
module.exports = new Command();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmV3LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NsaS9jbWRzL25ldy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CLHFDQUFxQztBQUNyQywrQkFBK0I7QUFDL0IseUNBQXlDO0FBQ3pDLDZDQUE2QztBQUM3Qyx5Q0FBeUM7QUFDekMscUNBQW1EO0FBQ25ELHNDQUE0QztBQUM1QyxvQ0FBaUM7QUFFakMsTUFBTSxPQUFPO0lBQWI7UUFDa0IsWUFBTyxHQUFHLDhCQUE4QixDQUFDO1FBQ3pDLGFBQVEsR0FBRyw4QkFBOEIsQ0FBQztJQXlFNUQsQ0FBQztJQXZFUSxPQUFPLENBQUMsSUFBZ0I7O1FBQzdCLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxFQUFFLEVBQUUsUUFBUSxFQUFFLDZGQUE2RixFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQzdKLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSx3Q0FBd0MsRUFBRSxDQUFDLENBQUM7UUFDekcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLDhFQUE4RSxFQUFFLENBQUMsQ0FBQztRQUNsSixJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsdUhBQXVILEVBQUUsQ0FBQyxDQUFDO1FBQ25MLElBQUksQ0FBQyxPQUFPLENBQUMsMEJBQTBCLEVBQUUsd0RBQXdELENBQUMsQ0FBQztRQUNuRyxJQUFJLENBQUMsT0FBTyxDQUFDLGlDQUFpQyxFQUFFLHVGQUF1RixD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T0FBTyxHQUFHLElBQUksT0FBTyxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgaW5xdWlyZXIgZnJvbSAnaW5xdWlyZXInO1xuaW1wb3J0ICogYXMgeWFyZ3MgZnJvbSAneWFyZ3MnO1xuaW1wb3J0IHsgUFJPSkVOX1JDIH0gZnJvbSAnLi4vLi4vY29tbW9uJztcbmltcG9ydCAqIGFzIGludmVudG9yeSBmcm9tICcuLi8uLi9pbnZlbnRvcnknO1xuaW1wb3J0ICogYXMgbG9nZ2luZyBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IGV4ZWMsIGV4ZWNPclVuZGVmaW5lZCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgdHJ5UHJvY2Vzc01hY3JvIH0gZnJvbSAnLi4vbWFjcm9zJztcbmltcG9ydCB7IHN5bnRoIH0gZnJvbSAnLi4vc3ludGgnO1xuXG5jbGFzcyBDb21tYW5kIGltcGxlbWVudHMgeWFyZ3MuQ29tbWFuZE1vZHVsZSB7XG4gIHB1YmxpYyByZWFkb25seSBjb21tYW5kID0gJ25ldyBbUFJPSkVDVC1UWVBFXSBbT1BUSU9OU10nO1xuICBwdWJsaWMgcmVhZG9ubHkgZGVzY3JpYmUgPSAnQ3JlYXRlcyBhIG5ldyBwcm9qZW4gcHJvamVjdCc7XG5cbiAgcHVibGljIGJ1aWxkZXIoYXJnczogeWFyZ3MuQXJndikge1xuICAgIGFyZ3MucG9zaXRpb25hbCgnUFJPSkVDVC1UWVBFJywgeyBkZXNjcmliZTogJ29wdGlvbmFsIG9ubHkgd2hlbiAtLWZyb20gaXMgdXNlZCBhbmQgdGhlcmUgaXMgYSBzaW5nbGUgcHJvamVjdCB0eXBlIGluIHRoZSBleHRlcm5hbCBtb2R1bGUnLCB0eXBlOiAnc3RyaW5nJyB9KTtcbiAgICBhcmdzLm9wdGlvbignc3ludGgnLCB7IHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogdHJ1ZSwgZGVzYzogJ1N5bnRoZXNpemUgYWZ0ZXIgY3JlYXRpbmcgLnByb2plbnJjLmpzJyB9KTtcbiAgICBhcmdzLm9wdGlvbignY29tbWVudHMnLCB7IHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogdHJ1ZSwgZGVzYzogJ0luY2x1ZGUgY29tbWVudGVkIG91dCBvcHRpb25zIGluIC5wcm9qZW5yYy5qcyAodXNlIC0tbm8tY29tbWVudHMgdG8gZGlzYWJsZSknIH0pO1xuICAgIGFyZ3Mub3B0aW9uKCdmcm9tJywgeyB0eXBlOiAnc3RyaW5nJywgYWxpYXM6ICdmJywgZGVzYzogJ0V4dGVybmFsIGpzaWkgbnBtIG1vZHVsZSB0byBjcmVhdGUgcHJvamVjdCBmcm9tLiBTdXBwb3J0cyBhbnkgcGFja2FnZSBzcGVjIHN1cHBvcnRlZCBieSB5YXJuIChzdWNoIGFzIFwibXktcGFja0BeMi4wXCIpJyB9KTtcbiAgICBhcmdzLmV4YW1wbGUoJ3Byb2plbiBuZXcgYXdzY2RrLWFwcC10cycsICdDcmVhdGVzIGEgbmV3IHByb2plY3Qgb2YgYnVpbHQtaW4gdHlwZSBcImF3c2Nkay1hcHAtdHNcIicpO1xuICAgIGFyZ3MuZXhhbXBsZSgncHJvamVuIG5ldyAtLWZyb20gcHJvamVuLXZ1ZUBeMicsICdDcmVhdGVzIGEgbmV3IHByb2plY3QgZnJvbSBhbiBleHRlcm5hbCBtb2R1bGUgXCJwcm9qZW4tdnVlXCIgd2l0aCB0aGUgc3BlY2lmaWVkIHZlcnNpb24nKTtcblxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBpbnZlbnRvcnkuZGlzY292ZXIoKSkge1xuICAgICAgYXJncy5jb21tYW5kKHR5cGUucGppZCwgdHlwZS5kb2NzID8/ICcnLCB7XG4gICAgICAgIGJ1aWxkZXI6IGNhcmdzID0+IHtcbiAgICAgICAgICBjYXJncy5zaG93SGVscE9uRmFpbCh0cnVlKTtcblxuICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHR5cGUub3B0aW9ucyA/PyBbXSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi50eXBlICE9PSAnc3RyaW5nJyAmJiBvcHRpb24udHlwZSAhPT0gJ251bWJlcicgJiYgb3B0aW9uLnR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICBjb250aW51ZTsgLy8gd2UgZG9uJ3Qgc3VwcG9ydCBub24tcHJpbWl0aXZlIGZpZWxkcyBhcyBjb21tYW5kIGxpbmUgb3B0aW9uc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZGVzYyA9IFtvcHRpb24uZG9jcz8ucmVwbGFjZSgvXFwgKlxcLiQvLCAnJykgPz8gJyddO1xuXG4gICAgICAgICAgICBjb25zdCByZXF1aXJlZCA9ICFvcHRpb24ub3B0aW9uYWw7XG4gICAgICAgICAgICBsZXQgZGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9uLmRlZmF1bHQgJiYgb3B0aW9uLmRlZmF1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGlmICghcmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmllbGQgaXMgbm90IHJlcXVpcmVkLCBqdXN0IGRlc2NyaWJlIHRoZSBkZWZhdWx0IGJ1dCBkb24ndCBhY3R1YWxseSBhc3NpZ24gYSB2YWx1ZVxuICAgICAgICAgICAgICAgIGRlc2MucHVzaChgW2RlZmF1bHQ6ICR7b3B0aW9uLmRlZmF1bHQucmVwbGFjZSgvXlxcICotLywgJycpLnJlcGxhY2UoL1xcLiQvLCAnJykudHJpbSgpfV1gKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmllbGQgaXMgcmVxdWlyZWQgYW5kIHdlIGhhdmUgYSBAZGVmYXVsdCwgdGhlbiBhc3NpZ25cbiAgICAgICAgICAgICAgICAvLyB0aGUgdmFsdWUgaGVyZSBzbyBpdCBhcHBlYXJzIGluIGAtLWhlbHBgXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gcmVuZGVyRGVmYXVsdChvcHRpb24uZGVmYXVsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FyZ3Mub3B0aW9uKG9wdGlvbi5zd2l0Y2gsIHtcbiAgICAgICAgICAgICAgZ3JvdXA6IHJlcXVpcmVkID8gJ1JlcXVpcmVkOicgOiAnT3B0aW9uYWw6JyxcbiAgICAgICAgICAgICAgdHlwZTogb3B0aW9uLnR5cGUsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjLmpvaW4oJyAnKSxcbiAgICAgICAgICAgICAgZGVmYXVsdDogZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlcjogYXJndiA9PiBuZXdQcm9qZWN0KHByb2Nlc3MuY3dkKCksIHR5cGUsIGFyZ3YpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaGFuZGxlcihhcmdzOiBhbnkpIHtcbiAgICAvLyBoYW5kbGUgLS1mcm9tIHdoaWNoIG1lYW5zIHdlIHdhbnQgdG8gZmlyc3QgaW5zdGFsbCBhIGpzaWkgbW9kdWxlIGFuZCB0aGVuXG4gICAgLy8gY3JlYXRlIGEgcHJvamVjdCBkZWZpbmVkIHdpdGhpbiB0aGlzIG1vZHVsZS5cbiAgICBpZiAoYXJncy5mcm9tKSB7XG4gICAgICByZXR1cm4gbmV3UHJvamVjdEZyb21Nb2R1bGUocHJvY2Vzcy5jd2QoKSwgYXJncy5mcm9tLCBhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBwcm9qZWN0IHR5cGUgaXMgZGVmaW5lZCBidXQgd2FzIG5vdCBtYXRjaGVkIGJ5IHlhcmdzLCBzbyBwcmludCB0aGUgbGlzdCBvZiBzdXBwb3J0ZWQgdHlwZXNcbiAgICBpZiAoYXJncy5wcm9qZWN0VHlwZSkge1xuICAgICAgY29uc29sZS5sb2coYEludmFsaWQgcHJvamVjdCB0eXBlICR7YXJncy5wcm9qZWN0VHlwZX0uIFN1cHBvcnRlZCB0eXBlczpgKTtcbiAgICAgIGZvciAoY29uc3QgcGppZCBvZiBpbnZlbnRvcnkuZGlzY292ZXIoKS5tYXAoeCA9PiB4LnBqaWQpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICR7cGppZH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGVzIHRoZSB1c2UgY2FzZSB0aGF0IG5vdGhpbmcgd2FzIHNwZWNpZmllZCBzaW5jZSBQUk9KRUNULVRZUEUgaXMgbm93IGFuIG9wdGlvbmFsIHBvc2l0aW9uYWwgcGFyYW1ldGVyXG4gICAgeWFyZ3Muc2hvd0hlbHAoKTtcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gYmFzZURpciBCYXNlIGRpcmVjdG9yeSBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBmaWxlc1xuICogQHBhcmFtIHR5cGUgUHJvamVjdCB0eXBlXG4gKiBAcGFyYW0gcGFyYW1zIE9iamVjdCB3aXRoIHBhcmFtZXRlciBkZWZhdWx0IHZhbHVlcy4gVmFsdWVzIHNob3VsZCBiZSBzdHJpbmdzXG4gKiBAcGFyYW0gY29tbWVudHMgV2hldGhlciB0byBpbmNsdWRlIG9wdGlvbmFsIHBhcmFtZXRlcnMgaW4gY29tbWVudGVkIG91dCBmb3JtXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUHJvamVuQ29uZmlnKGJhc2VEaXI6IHN0cmluZywgdHlwZTogaW52ZW50b3J5LlByb2plY3RUeXBlLCBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIGNvbW1lbnRzOiBib29sZWFuKSB7XG4gIGNvbnN0IGNvbmZpZ1BhdGggPSBwYXRoLmpvaW4oYmFzZURpciwgUFJPSkVOX1JDKTtcbiAgaWYgKGZzLmV4aXN0c1N5bmMoY29uZmlnUGF0aCkpIHtcbiAgICBsb2dnaW5nLmVycm9yKGBEaXJlY3RvcnkgJHtiYXNlRGlyfSBhbHJlYWR5IGNvbnRhaW5zICR7UFJPSkVOX1JDfWApO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfVxuXG4gIGNvbnN0IFtpbXBvcnROYW1lXSA9IHR5cGUudHlwZW5hbWUuc3BsaXQoJy4nKTtcblxuICBjb25zdCBsaW5lcyA9IFtcbiAgICBgY29uc3QgeyAke2ltcG9ydE5hbWV9IH0gPSByZXF1aXJlKCcke3R5cGUubW9kdWxlTmFtZX0nKTtgLFxuICAgICcnLFxuICAgIGBjb25zdCBwcm9qZWN0ID0gbmV3ICR7dHlwZS50eXBlbmFtZX0oJHtyZW5kZXJQYXJhbXModHlwZSwgcGFyYW1zLCBjb21tZW50cyl9KTtgLFxuICAgICcnLFxuICAgICdwcm9qZWN0LnN5bnRoKCk7JyxcbiAgICAnJyxcbiAgXTtcblxuICBmcy53cml0ZUZpbGVTeW5jKGNvbmZpZ1BhdGgsIGxpbmVzLmpvaW4oJ1xcbicpKTtcbiAgbG9nZ2luZy5pbmZvKGBDcmVhdGVkICR7UFJPSkVOX1JDfSBmb3IgJHt0eXBlLnR5cGVuYW1lfWApO1xufVxuXG5mdW5jdGlvbiBtYWtlUGFkZGluZyhwYWRkaW5nTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gJyAnLnJlcGVhdChwYWRkaW5nTGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBQcmludHMgYWxsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmUgdXNlZCBpbiBhIHByb2plY3QgdHlwZSwgYWxvbmdzaWRlIHRoZWlyIGRlc2NyaXB0aW9ucy5cbiAqXG4gKiBQYXJhbWV0ZXJzIGluIGBwYXJhbXNgIHRoYXQgYXJlbid0IHVuZGVmaW5lZCBhcmUgcmVuZGVyZWQgYXMgZGVmYXVsdHMsXG4gKiB3aGlsZSBhbGwgb3RoZXIgcGFyYW1ldGVycyBhcmUgcmVuZGVyZWQgYXMgY29tbWVudGVkIG91dC5cbiAqXG4gKiBAcGFyYW0gdHlwZSBQcm9qZWN0IHR5cGVcbiAqIEBwYXJhbSBwYXJhbXMgT2JqZWN0IHdpdGggcGFyYW1ldGVyIGRlZmF1bHQgdmFsdWVzXG4gKiBAcGFyYW0gY29tbWVudHMgV2hldGhlciB0byBpbmNsdWRlIG9wdGlvbmFsIHBhcmFtZXRlcnMgaW4gY29tbWVudGVkIG91dCBmb3JtXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclBhcmFtcyh0eXBlOiBpbnZlbnRvcnkuUHJvamVjdFR5cGUsIHBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiwgY29tbWVudHM6IGJvb2xlYW4pIHtcbiAgLy8gcHJlcHJvY2Vzc2luZ1xuICBjb25zdCByZW5kZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGNvbnN0IG9wdGlvbnNXaXRoRGVmYXVsdHM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IG9wdGlvbnNCeU1vZHVsZTogUmVjb3JkPHN0cmluZywgaW52ZW50b3J5LlByb2plY3RPcHRpb25bXT4gPSB7fTsgLy8gb25seSBvcHRpb25zIHdpdGhvdXQgZGVmYXVsdHNcblxuICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0eXBlLm9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9uLmRlcHJlY2F0ZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbk5hbWUgPSBvcHRpb24ubmFtZTtcbiAgICBsZXQgcGFyYW1SZW5kZXI7XG4gICAgaWYgKHBhcmFtc1tvcHRpb25OYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJhbVJlbmRlciA9IGAke29wdGlvbk5hbWV9OiAke3BhcmFtc1tvcHRpb25OYW1lXX0sYDtcbiAgICAgIG9wdGlvbnNXaXRoRGVmYXVsdHMucHVzaChvcHRpb25OYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0aW9uLmRlZmF1bHQ/LnN0YXJ0c1dpdGgoJy0nKSA/IHVuZGVmaW5lZCA6IChvcHRpb24uZGVmYXVsdCA/PyB1bmRlZmluZWQpO1xuICAgICAgcGFyYW1SZW5kZXIgPSBgLy8gJHtvcHRpb25OYW1lfTogJHtkZWZhdWx0VmFsdWU/LnJlcGxhY2UoL1wiKC4rKVwiLywgJ1xcJyQxXFwnJyl9LGA7IC8vIHNpbmdsZSBxdW90ZXNcblxuICAgICAgY29uc3QgcGFyZW50TW9kdWxlID0gb3B0aW9uLnBhcmVudDtcbiAgICAgIG9wdGlvbnNCeU1vZHVsZVtwYXJlbnRNb2R1bGVdID0gb3B0aW9uc0J5TW9kdWxlW3BhcmVudE1vZHVsZV0gPz8gW107XG4gICAgICBvcHRpb25zQnlNb2R1bGVbcGFyZW50TW9kdWxlXS5wdXNoKG9wdGlvbik7XG4gICAgfVxuICAgIHJlbmRlcnNbb3B0aW9uTmFtZV0gPSBwYXJhbVJlbmRlcjtcbiAgfVxuXG4gIC8vIGFscGhhYmV0aXplXG4gIGNvbnN0IG1hcmdpblNpemUgPSBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKHJlbmRlcnMpLm1hcChzdHIgPT4gc3RyLmxlbmd0aCkpO1xuICBvcHRpb25zV2l0aERlZmF1bHRzLnNvcnQoKTtcbiAgZm9yIChjb25zdCBwYXJlbnRNb2R1bGUgaW4gb3B0aW9uc0J5TW9kdWxlKSB7XG4gICAgb3B0aW9uc0J5TW9kdWxlW3BhcmVudE1vZHVsZV0uc29ydCgobzEsIG8yKSA9PiBvMS5uYW1lLmxvY2FsZUNvbXBhcmUobzIubmFtZSkpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgcmVuZGVyaW5nXG4gIGNvbnN0IHRhYiA9IG1ha2VQYWRkaW5nKDIpO1xuICBjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW107XG4gIHJlc3VsdC5wdXNoKCd7Jyk7XG5cbiAgLy8gcmVuZGVyIG9wdGlvbnMgd2l0aCBkZWZhdWx0c1xuICBmb3IgKGNvbnN0IG9wdGlvbk5hbWUgb2Ygb3B0aW9uc1dpdGhEZWZhdWx0cykge1xuICAgIHJlc3VsdC5wdXNoKGAke3RhYn0ke3JlbmRlcnNbb3B0aW9uTmFtZV19YCk7XG4gIH1cbiAgaWYgKHJlc3VsdC5sZW5ndGggPiAxKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG5cbiAgLy8gcmVuZGVyIG9wdGlvbnMgd2l0aG91dCBkZWZhdWx0c1xuICBpZiAoY29tbWVudHMpIHtcbiAgICBmb3IgKGNvbnN0IFttb2R1bGVOYW1lLCBvcHRpb25zXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zQnlNb2R1bGUpLnNvcnQoKSkge1xuICAgICAgcmVzdWx0LnB1c2goYCR7dGFifS8qICR7bW9kdWxlTmFtZX0gKi9gKTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1SZW5kZXIgPSByZW5kZXJzW29wdGlvbi5uYW1lXTtcbiAgICAgICAgcmVzdWx0LnB1c2goYCR7dGFifSR7cGFyYW1SZW5kZXJ9JHttYWtlUGFkZGluZyhtYXJnaW5TaXplIC0gcGFyYW1SZW5kZXIubGVuZ3RoICsgMil9LyogJHtvcHRpb24uZG9jc30gKi9gKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgcmVzdWx0LnBvcCgpO1xuICB9XG4gIHJlc3VsdC5wdXNoKCd9Jyk7XG4gIHJldHVybiByZXN1bHQuam9pbignXFxuJyk7XG59XG5cbi8qKlxuICogR2l2ZW4gYSB2YWx1ZSBmcm9tIFwiQGRlZmF1bHRcIiwgcHJvY2Vzc2VzIG1hY3JvcyBhbmQgcmV0dXJucyBhIHN0cmluZ2llZFxuICogKHF1b3RlZCkgcmVzdWx0LlxuICpcbiAqIEByZXR1cm5zIGEgamF2YXNjcmlwdCBwcmltaXRpdmUgKGNvdWxkIGJlIGEgc3RyaW5nLCBudW1iZXIgb3IgYm9vbGVhbilcbiAqL1xuZnVuY3Rpb24gcmVuZGVyRGVmYXVsdCh2YWx1ZTogc3RyaW5nKSB7XG4gIHJldHVybiB0cnlQcm9jZXNzTWFjcm8odmFsdWUpID8/IEpTT04ucGFyc2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHlhcmdzIGNvbW1hbmQgbGluZSBzd2l0Y2hlcyB0byBwcm9qZWN0IHR5cGUgcHJvcHMuXG4gKiBAcGFyYW0gdHlwZSBQcm9qZWN0IHR5cGVcbiAqIEBwYXJhbSBhcmd2IENvbW1hbmQgbGluZSBzd2l0Y2hlc1xuICovXG5mdW5jdGlvbiBjb21tYW5kTGluZVRvUHJvcHModHlwZTogaW52ZW50b3J5LlByb2plY3RUeXBlLCBhcmd2OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBwcm9wczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuXG4gIC8vIGluaXRpYWxpemUgcHJvcHMgd2l0aCBkZWZhdWx0IHZhbHVlc1xuICBmb3IgKGNvbnN0IHByb3Agb2YgdHlwZS5vcHRpb25zKSB7XG4gICAgaWYgKHByb3AuZGVmYXVsdCAmJiBwcm9wLmRlZmF1bHQgIT09ICd1bmRlZmluZWQnICYmICFwcm9wLm9wdGlvbmFsKSB7XG4gICAgICBwcm9wc1twcm9wLm5hbWVdID0gcmVuZGVyRGVmYXVsdChwcm9wLmRlZmF1bHQpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgW2FyZywgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFyZ3YpKSB7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHR5cGUub3B0aW9ucykge1xuICAgICAgaWYgKHByb3Auc3dpdGNoID09PSBhcmcpIHtcbiAgICAgICAgbGV0IGN1cnIgPSBwcm9wcztcbiAgICAgICAgY29uc3QgcXVldWUgPSBbLi4ucHJvcC5wYXRoXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBwID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gdmFsdWU7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBzdHJpbmcsIHRoZW4gc2luZ2xlIHF1b3RlIGl0XG4gICAgICAgICAgICBpZiAodmFsICYmIHR5cGVvZih2YWwpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB2YWwgPSBKU09OLnN0cmluZ2lmeSh2YWwpLnJlcGxhY2UoL1wiKC4rKVwiLywgJ1xcJyQxXFwnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJbcF0gPSB2YWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJbcF0gPSBjdXJyW3BdID8/IHt9O1xuICAgICAgICAgICAgY3VyciA9IGN1cnJbcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG5ldyBwcm9qZWN0IGZyb20gYW4gZXh0ZXJuYWwgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBzcGVjIFRoZSBuYW1lIG9mIHRoZSBleHRlcm5hbCBtb2R1bGUgdG8gbG9hZFxuICogQHBhcmFtIGFyZ3MgQ29tbWFuZCBsaW5lIGFyZ3VtZW50cyAoaW5jbC4gcHJvamVjdCB0eXBlKVxuICovXG5hc3luYyBmdW5jdGlvbiBuZXdQcm9qZWN0RnJvbU1vZHVsZShiYXNlRGlyOiBzdHJpbmcsIHNwZWM6IHN0cmluZywgYXJnczogYW55KSB7XG4gIGNvbnN0IHNwZWNEZXBlbmRlbmN5SW5mbyA9IHlhcm5BZGQoYmFzZURpciwgc3BlYyk7XG5cbiAgLy8gY29sbGVjdCBwcm9qZWN0cyBieSBsb29raW5nIHVwIGFsbCAuanNpaSBtb2R1bGVzIGluIGBub2RlX21vZHVsZXNgLlxuICBjb25zdCBtb2R1bGVzRGlyID0gcGF0aC5qb2luKGJhc2VEaXIsICdub2RlX21vZHVsZXMnKTtcbiAgY29uc3QgbW9kdWxlcyA9IGZzLnJlYWRkaXJTeW5jKG1vZHVsZXNEaXIpLm1hcChmaWxlID0+IHBhdGguam9pbihtb2R1bGVzRGlyLCBmaWxlKSk7XG4gIGNvbnN0IHByb2plY3RzID0gaW52ZW50b3J5XG4gICAgLmRpc2NvdmVyKC4uLm1vZHVsZXMpXG4gICAgLmZpbHRlcih4ID0+IHgubW9kdWxlTmFtZSAhPT0gJ3Byb2plbicpOyAvLyBmaWx0ZXIgYnVpbHQtaW4gcHJvamVjdCB0eXBlc1xuXG4gIGlmIChwcm9qZWN0cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBwcm9qZWN0cyBmb3VuZCBhZnRlciBpbnN0YWxsaW5nICR7c3BlY30uIFRoZSBtb2R1bGUgbXVzdCBleHBvcnQgYXQgbGVhc3Qgb25lIGNsYXNzIHdoaWNoIGV4dGVuZHMgcHJvamVuLlByb2plY3RgKTtcbiAgfVxuXG4gIGNvbnN0IHJlcXVlc3RlZCA9IGFyZ3MucHJvamVjdFR5cGU7XG4gIGNvbnN0IHR5cGVzID0gcHJvamVjdHMubWFwKHAgPT4gcC5wamlkKTtcblxuICAvLyBpZiB1c2VyIGRpZCBub3Qgc3BlY2lmeSBhIHByb2plY3QgdHlwZSBidXQgdGhlIG1vZHVsZSBoYXMgbW9yZSB0aGFuIG9uZSwgd2UgbmVlZCB0aGVtIHRvIHRlbGwgdXMgd2hpY2ggb25lLi4uXG4gIGlmICghcmVxdWVzdGVkICYmIHByb2plY3RzLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGxlIHByb2plY3RzIGZvdW5kIGFmdGVyIGluc3RhbGxpbmcgJHtzcGVjfTogJHt0eXBlcy5qb2luKCcsJyl9LiBQbGVhc2Ugc3BlY2lmeSBhIHByb2plY3QgbmFtZS5cXG5FeGFtcGxlOiBucHggcHJvamVuIG5ldyAtLWZyb20gJHtzcGVjfSAke3R5cGVzWzBdfWApO1xuICB9XG5cbiAgLy8gaWYgdXNlciBkaWQgbm90IHNwZWNpZnkgYSB0eXBlIChhbmQgd2Uga25vdyB3ZSBoYXZlIG9ubHkgb25lKSwgdGhlIHNlbGVjdCBpdC4gb3RoZXJ3aXNlLCBzZWFyY2ggYnkgcGppZC5cbiAgY29uc3QgdHlwZSA9ICFyZXF1ZXN0ZWQgPyBwcm9qZWN0c1swXSA6IHByb2plY3RzLmZpbmQocCA9PiBwLnBqaWQgPT09IHJlcXVlc3RlZCk7XG4gIGlmICghdHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgUHJvamVjdCB0eXBlICR7cmVxdWVzdGVkfSBub3QgZm91bmQuIEZvdW5kICR7dHlwZXMuam9pbignLCcpfWApO1xuICB9XG5cbiAgLy8gaW5jbHVkZSBhIGRldiBkZXBlbmRlbmN5IGZvciB0aGUgZXh0ZXJuYWwgbW9kdWxlXG4gIGF3YWl0IG5ld1Byb2plY3QoYmFzZURpciwgdHlwZSwgYXJncywge1xuICAgIGRldkRlcHM6IEpTT04uc3RyaW5naWZ5KFtzcGVjRGVwZW5kZW5jeUluZm9dKSxcbiAgfSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbmV3IHByb2plY3QuXG4gKiBAcGFyYW0gdHlwZSBQcm9qZWN0IHR5cGVcbiAqIEBwYXJhbSBhcmdzIENvbW1hbmQgbGluZSBhcmd1bWVudHNcbiAqIEBwYXJhbSBhZGRpdGlvbmFsUHJvcHMgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gLnByb2plbnJjLmpzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG5ld1Byb2plY3QoYmFzZURpcjogc3RyaW5nLCB0eXBlOiBpbnZlbnRvcnkuUHJvamVjdFR5cGUsIGFyZ3M6IGFueSwgYWRkaXRpb25hbFByb3BzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAvLyBjb252ZXJ0IGNvbW1hbmQgbGluZSBhcmd1bWVudHMgdG8gcHJvamVjdCBwcm9wcyB1c2luZyB0eXBlIGluZm9ybWF0aW9uXG4gIGNvbnN0IHByb3BzID0gY29tbWFuZExpbmVUb1Byb3BzKHR5cGUsIGFyZ3MpO1xuXG4gIC8vIG1lcmdlIGluIGFkZGl0aW9uYWwgcHJvcHMgaWYgc3BlY2lmaWVkXG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGFkZGl0aW9uYWxQcm9wcyA/PyB7fSkpIHtcbiAgICBwcm9wc1trXSA9IHY7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSAucHJvamVucmMuanNcbiAgZ2VuZXJhdGVQcm9qZW5Db25maWcoYmFzZURpciwgdHlwZSwgcHJvcHMsIGFyZ3MuY29tbWVudHMpO1xuXG4gIC8vIGludGVyYWN0aXZlIGdpdCBhbmQgZ2l0aHViIHNldHVwXG4gIGNvbnN0IGdpdEZvbGRlciA9IHBhdGgucmVzb2x2ZSgnLmdpdCcpO1xuICBsZXQgcHVzaEluaXRpYWxUb0dpdGh1YiA9IGZhbHNlO1xuXG4gIGlmICghZnMuZXhpc3RzU3luYyhnaXRGb2xkZXIpKSB7XG4gICAgcHVzaEluaXRpYWxUb0dpdGh1YiA9IGF3YWl0IGFza0Fib3V0R2l0KCk7XG4gIH1cblxuICAvLyBzeW50aGVzaXplIGlmIHN5bnRoIGlzIGVuYWJsZWQgKGRlZmF1bHQpLlxuICBpZiAoYXJncy5zeW50aCkge1xuICAgIHByb2Nlc3MuZW52LlBST0pFTl9ESVNBQkxFX1BPU1QgPSAoIWFyZ3MucG9zdCkudG9TdHJpbmcoKTtcbiAgICBhd2FpdCBzeW50aCgpO1xuICB9XG5cbiAgaWYgKHB1c2hJbml0aWFsVG9HaXRodWIpIHtcbiAgICBleGVjKCdnaXQgYWRkIC4nKTtcbiAgICBleGVjKCdnaXQgY29tbWl0IC1tIFxcJ0luaXRpYWwgY29tbWl0IGdlbmVyYXRlZCBieSBwcm9qZW5cXCcnKTtcbiAgICBleGVjKCdnaXQgYnJhbmNoIC1NIG1haW4nKTtcbiAgICBleGVjKCdnaXQgcHVzaCAtLXNldC11cHN0cmVhbSBvcmlnaW4gbWFpbicpO1xuICB9XG59XG5cbi8qKlxuICogSW5zdGFsbHMgdGhlIG5wbSBtb2R1bGUgKHRocm91Z2ggYHlhcm4gYWRkYCkgdG8gbm9kZV9tb2R1bGVzIHVuZGVyIGBwcm9qZWN0RGlyYC5cbiAqIEBwYXJhbSBzcGVjIFRoZSBucG0gcGFja2FnZSBzcGVjIChlLmcuIGZvb0BeMS4yKVxuICogQHJldHVybnMgU3RyaW5nIGluZm8gZm9yIHRoZSBwcm9qZWN0IGRldkRlcHMgKGUuZy4gZm9vQF4xLjIgb3IgZm9vQC92YXIvZm9sZGVycy84ay9xY3cwbHM1cHZfcGgwMDAwZ24vVC9wcm9qZW4tUll1ckN3L3BrZy50Z3opXG4gKi9cbmZ1bmN0aW9uIHlhcm5BZGQoYmFzZURpcjogc3RyaW5nLCBzcGVjOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSBwYXRoLmpvaW4oYmFzZURpciwgJ3BhY2thZ2UuanNvbicpO1xuICBjb25zdCBwYWNrYWdlSnNvbkV4aXN0ZWQgPSBmcy5leGlzdHNTeW5jKHBhY2thZ2VKc29uUGF0aCk7XG4gIGxldCBkZXBlbmRlbmN5SW5mbyA9IHNwZWM7XG5cbiAgLy8gd29ya2Fyb3VuZDogeWFybiBmYWlscyB0byBleHRyYWN0IHRneiBpZiBpdCBjb250YWlucyAnQCcgaW4gdGhlIG5hbWUsIHNvIHdlXG4gIC8vIGNyZWF0ZSBhIHRlbXAgY29weSBjYWxsZWQgcGtnLnRneiBhbmQgaW5zdGFsbCBmcm9tIHRoZXJlLlxuICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS95YXJucGtnL3lhcm4vaXNzdWVzLzYzMzlcbiAgaWYgKHNwZWMuZW5kc1dpdGgoJy50Z3onKSAmJiBzcGVjLmluY2x1ZGVzKCdAJykpIHtcbiAgICAvLyBpZiB1c2VyIHBhc3NlcyBpbiBhIGZpbGUgc3BlYyB0aGVuIHdlIGhhdmUgdG8gc3BlY2lmeSB0aGUgcHJvamVjdCBuYW1lIGFuZCB0aGUgcGFja2FnZSBsb2NhdGlvblxuICAgIC8vIChlLmcgZm9vQC92YXIvZm9sZGVycy84ay9xY3cwbHM1cHZfcGgwMDAwZ24vVC9wcm9qZW4tUll1ckN3L3BrZy50Z3opXG4gICAgY29uc3QgbW9kdWxlTmFtZSA9IHNwZWMuc3BsaXQoJy8nKS5zbGljZSgtMSlbMF0udHJpbSgpLnNwbGl0KCdAJylbMF0udHJpbSgpOyAvLyBFeGFtcGxlOiAuL2Nkay1wcm9qZWN0L2Rpc3QvanMvY2RrLXByb2plY3RAMS4wLjAuanNpaS50Z3pcblxuICAgIGNvbnN0IHRtcGRpciA9IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ3Byb2plbi0nKSk7XG4gICAgY29uc3QgY29weSA9IHBhdGguam9pbih0bXBkaXIsICdwa2cudGd6Jyk7XG4gICAgZnMuY29weUZpbGVTeW5jKHNwZWMsIGNvcHkpO1xuICAgIHNwZWMgPSBjb3B5O1xuXG4gICAgZGVwZW5kZW5jeUluZm8gPSBgJHttb2R1bGVOYW1lfUAke3NwZWN9YDtcbiAgfVxuXG4gIGxvZ2dpbmcuaW5mbyhgaW5zdGFsbGluZyBleHRlcm5hbCBtb2R1bGUgJHtzcGVjfS4uLmApO1xuICBleGVjKGB5YXJuIGFkZCAtLW1vZHVsZXMtZm9sZGVyPSR7YmFzZURpcn0vbm9kZV9tb2R1bGVzIC0tc2lsZW50IC0tbm8tbG9ja2ZpbGUgLS1kZXYgJHtzcGVjfWAsIHsgY3dkOiBiYXNlRGlyIH0pO1xuXG4gIC8vIGlmIHBhY2thZ2UuanNvbiBkaWQgbm90IGV4aXN0IGJlZm9yZSBjYWxsaW5nIHlhcm4gYWRkLCB3ZSBzaG91bGQgcmVtb3ZlIGl0XG4gIC8vIHNvIHdlIGNhbiBzdGFydCBvZmYgY2xlYW4uXG4gIGlmICghcGFja2FnZUpzb25FeGlzdGVkKSB7XG4gICAgZnMucmVtb3ZlU3luYyhwYWNrYWdlSnNvblBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIGRlcGVuZGVuY3lJbmZvO1xufVxuXG5hc3luYyBmdW5jdGlvbiBhc2tBYm91dEdpdCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgbG9nZ2luZy5pbmZvKCdXZSBub3RpY2UgdGhhdCB5b3UgZG8gbm90IGhhdmUgYSBsb2NhbCBnaXQgcmVwb3NpdG9yeS4nKTtcbiAgY29uc3QgeyBzZXRVcEdpdCB9ID0gYXdhaXQgaW5xdWlyZXIucHJvbXB0KFtcbiAgICB7XG4gICAgICB0eXBlOiAnY29uZmlybScsXG4gICAgICBuYW1lOiAnc2V0VXBHaXQnLFxuICAgICAgbWVzc2FnZTogJ0RvIHlvdSB3YW50IHRvIHNldCB0aGF0IHVwIG5vdz8nLFxuICAgIH0sXG4gIF0pO1xuXG4gIGlmIChzZXRVcEdpdCkge1xuICAgIGNvbnN0IHsgcGxhbiB9ID0gYXdhaXQgaW5xdWlyZXIucHJvbXB0KGdpdGh1YlBsYW5PcHRpb25zKTtcblxuICAgIGNvbnN0IHsgZ2gsIGdpdCB9ID0gcGxhbjtcblxuICAgIGlmICghZ2l0ICYmICFnaCkge1xuICAgICAgZXhlYygnZ2l0IGluaXQnKTtcbiAgICAgIGxvZ2dpbmcuaW5mbygnT2ssIHdlXFwndmUgXFwnZ2l0IGluaXRcXCdkIGZvciB5b3UhIEhhdmUgYSBncmVhdCBkYXkuJyk7XG4gICAgfVxuXG4gICAgaWYgKGdpdCkge1xuICAgICAgY29uc3QgeyBnaXRSZXBvVVJMIH0gPSBhd2FpdCBpbnF1aXJlci5wcm9tcHQoW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgICAgICBuYW1lOiAnZ2l0UmVwb1VSTCcsXG4gICAgICAgICAgbWVzc2FnZTogJ1doYXQgaXMgdGhlIHJlcG8/IChleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvamVuL3Byb2plbiknLFxuICAgICAgICB9LFxuICAgICAgXSk7XG5cbiAgICAgIGV4ZWMoJ2dpdCBpbml0Jyk7XG5cbiAgICAgIGxldCBmb3JtYXR0ZWRHaXRSZXBvVVJMID0gZ2l0UmVwb1VSTDtcbiAgICAgIGlmICghZ2l0UmVwb1VSTC5pbmNsdWRlcygnaHR0cHMnKSkge1xuICAgICAgICBmb3JtYXR0ZWRHaXRSZXBvVVJMID0gYGh0dHBzOi8vZ2l0aHViLmNvbS8ke2dpdFJlcG9VUkx9YDtcbiAgICAgIH1cblxuICAgICAgZXhlYyhgZ2l0IHJlbW90ZSBhZGQgb3JpZ2luICR7Zm9ybWF0dGVkR2l0UmVwb1VSTH1gKTtcblxuICAgICAgbG9nZ2luZy5pbmZvKGBHcmVhdCEgV2UndmUgJ2dpdCBpbml0J2QgZm9yIHlvdSBhbmQgc2V0IHRoZSByZW1vdGUgdG8gJHtmb3JtYXR0ZWRHaXRSZXBvVVJMfWApO1xuICAgIH1cblxuICAgIGlmICghZ2l0ICYmIGdoKSB7XG4gICAgICBsb2dnaW5nLmluZm8oJ09rISBXZSB3aWxsIG1ha2UgeW91IGEgcmVwb3NpdG9yeSBvbiBHaXRIdWIuJyk7XG5cbiAgICAgIGNvbnN0IGdoQ0xJUGF0aCA9IGV4ZWNPclVuZGVmaW5lZChgJHtvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInID8gJ3doZXJlJyA6ICd3aGljaCd9IGdoYCk7XG5cbiAgICAgIGlmICghZ2hDTElQYXRoKSB7XG4gICAgICAgIGxvZ2dpbmcud2FybignTG9va3MgbGlrZSB5b3UgZG8gbm90IGhhdmUgdGhlIEdpdEh1YiBDTEkgaW5zdGFsbGVkLiBQbGVhc2UgZ28gdG8gaHR0cHM6Ly9jbGkuZ2l0aHViLmNvbS8gdG8gaW5zdGFsbCBhbmQgdHJ5IGFnYWluLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBnaXRQcm9qZWN0TmFtZSB9ID0gYXdhaXQgaW5xdWlyZXIucHJvbXB0KFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgICAgICAgbmFtZTogJ2dpdFByb2plY3ROYW1lJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdXaGF0IHdvdWxkIHlvdSBsaWtlIHRvIG5hbWUgaXQ/JyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHBhdGguYmFzZW5hbWUocGF0aC5kaXJuYW1lKHByb2Nlc3MuY3dkKCkpKSxcbiAgICAgICAgICB9LFxuICAgICAgICBdKTtcblxuICAgICAgICBsb2dnaW5nLmluZm8oYFdvdyEgJHtnaXRQcm9qZWN0TmFtZX0gaXMgc3VjaCBhIGdyZWF0IG5hbWUhYCk7XG5cbiAgICAgICAgZXhlYygnZ2l0IGluaXQnKTtcblxuICAgICAgICBleGVjKGBnaCByZXBvIGNyZWF0ZSAke2dpdFByb2plY3ROYW1lfWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBnaXRodWJQbGFuT3B0aW9ucyA9IFtcbiAge1xuICAgIHR5cGU6ICdsaXN0JyxcbiAgICBuYW1lOiAncGxhbicsXG4gICAgbWVzc2FnZTogJ1dlXFwnbGwgbmVlZCBzb21lIG1vcmUgaW5mby4gUGxlYXNlIGNob29zZSBvbmU6JyxcbiAgICBjaG9pY2VzOiBbXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgZ2l0OiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiAnSSBhbHJlYWR5IGhhdmUgYSBnaXQgcmVwb3NpdG9yeScsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGdoOiB0cnVlLFxuICAgICAgICAgIGdpdDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIG5hbWU6ICdJIGRvblxcJ3QgaGF2ZSBhIGdpdCByZXBvc2l0b3J5IGFuZCB3YW50IHRvIG1ha2Ugb25lIG9uIEdpdEh1YicsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGdoOiBmYWxzZSxcbiAgICAgICAgICBnaXQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiAnSSBkb25cXCd0IGhhdmUgYSBnaXQgcmVwb3NpdG9yeSBhbmQgSSBkb25cXCd0IHdhbnQgdG8gdXNlIEdpdEh1YicsXG4gICAgICB9LFxuICAgIF0sXG4gIH0sXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDb21tYW5kKCk7XG4iXX0=