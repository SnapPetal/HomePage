"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleFallback = void 0;
const error_1 = require("./error");
const default_1 = require("./default");
const headers_1 = require("./headers");
const notfound_1 = require("../route/notfound");
const renderFallback = async (event, route, manifest, routesManifest, getPage) => {
    const { req, res } = event;
    headers_1.setCustomHeaders(event, routesManifest);
    const page = getPage(route.page);
    try {
        const { html, renderOpts } = await page.renderReqToHTML(req, res, "passthrough");
        return { isStatic: false, route, html, renderOpts };
    }
    catch (error) {
        return error_1.renderErrorPage(error, event, route, manifest, routesManifest, getPage);
    }
};
/*
 * Handles fallback routes
 *
 * If route is a blocking fallback or a fallback data route,
 * a Fallback object is returned. It contains the rendered page.
 *
 * Otherwise either a page is rendered (like handleDefault) or
 * returns as StaticRoute for the caller to handle.
 */
const handleFallback = async (event, route, manifest, routesManifest, getPage) => {
    var _a;
    // This should not be needed if all SSR routes are handled correctly
    if (route.isRender) {
        return default_1.renderRoute(event, route, manifest, routesManifest, getPage);
    }
    if (route.isStatic) {
        const staticRoute = route;
        const shouldRender = (staticRoute.fallback && staticRoute.isData) ||
            staticRoute.fallback === null;
        if (shouldRender && staticRoute.page) {
            const fallback = staticRoute;
            return renderFallback(event, fallback, manifest, routesManifest, getPage);
        }
        if (staticRoute.fallback) {
            return { ...staticRoute, file: `pages${staticRoute.fallback}` };
        }
    }
    const errorRoute = notfound_1.notFoundPage((_a = event.req.url) !== null && _a !== void 0 ? _a : "", manifest, routesManifest);
    if (errorRoute.isStatic) {
        return errorRoute;
    }
    return default_1.renderRoute(event, errorRoute, manifest, routesManifest, getPage);
};
exports.handleFallback = handleFallback;
