"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NextJSLambdaEdge = void 0;
const cdk = __importStar(require("@aws-cdk/core"));
const lambda = __importStar(require("@aws-cdk/aws-lambda"));
const s3 = __importStar(require("@aws-cdk/aws-s3"));
const logs = __importStar(require("@aws-cdk/aws-logs"));
const s3Deploy = __importStar(require("@aws-cdk/aws-s3-deployment"));
const cloudfront = __importStar(require("@aws-cdk/aws-cloudfront"));
const origins = __importStar(require("@aws-cdk/aws-cloudfront-origins"));
const aws_route53_1 = require("@aws-cdk/aws-route53");
const sqs = __importStar(require("@aws-cdk/aws-sqs"));
const lambdaEventSources = __importStar(require("@aws-cdk/aws-lambda-event-sources"));
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const aws_iam_1 = require("@aws-cdk/aws-iam");
const core_1 = require("@aws-cdk/core");
const aws_route53_targets_1 = require("@aws-cdk/aws-route53-targets");
const aws_cloudfront_1 = require("@aws-cdk/aws-cloudfront");
const toLambdaOption_1 = require("./utils/toLambdaOption");
const readAssetsDirectory_1 = require("./utils/readAssetsDirectory");
const readInvalidationPathsFromManifest_1 = require("./utils/readInvalidationPathsFromManifest");
const reduceInvalidationPaths_1 = require("./utils/reduceInvalidationPaths");
const pathToPosix_1 = __importDefault(require("./utils/pathToPosix"));
__exportStar(require("./props"), exports);
class NextJSLambdaEdge extends cdk.Construct {
    constructor(scope, id, props) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        super(scope, id);
        this.props = props;
        this.apiBuildManifest = this.readApiBuildManifest();
        this.routesManifest = this.readRoutesManifest();
        this.imageManifest = this.readImageBuildManifest();
        this.defaultManifest = this.readDefaultManifest();
        this.prerenderManifest = this.readPrerenderManifest();
        this.bucket = new s3.Bucket(this, "PublicAssets", Object.assign({ publicReadAccess: true, 
            // Given this resource is created internally and also should only contain
            // assets uploaded by this library we should be able to safely delete all
            // contents along with the bucket its self upon stack deletion.
            autoDeleteObjects: true, removalPolicy: cdk.RemovalPolicy.DESTROY }, (props.s3Props || {})));
        const hasISRPages = Object.keys(this.prerenderManifest.routes).some((key) => typeof this.prerenderManifest.routes[key].initialRevalidateSeconds ===
            "number");
        if (hasISRPages) {
            this.regenerationQueue = new sqs.Queue(this, "RegenerationQueue", {
                // We call the queue the same name as the bucket so that we can easily
                // reference it from within the lambda@edge, given we can't use env vars
                // in a lambda@edge
                queueName: `${this.bucket.bucketName}.fifo`,
                fifo: true,
                removalPolicy: cdk.RemovalPolicy.DESTROY
            });
            this.regenerationFunction = new lambda.Function(this, "RegenerationFunction", {
                handler: "index.handler",
                runtime: lambda.Runtime.NODEJS_14_X,
                timeout: core_1.Duration.seconds(30),
                code: lambda.Code.fromAsset(path.join(this.props.serverlessBuildOutDir, "regeneration-lambda"))
            });
            this.regenerationFunction.addEventSource(new lambdaEventSources.SqsEventSource(this.regenerationQueue));
        }
        this.edgeLambdaRole = new aws_iam_1.Role(this, "NextEdgeLambdaRole", {
            assumedBy: new aws_iam_1.CompositePrincipal(new aws_iam_1.ServicePrincipal("lambda.amazonaws.com"), new aws_iam_1.ServicePrincipal("edgelambda.amazonaws.com")),
            managedPolicies: [
                aws_iam_1.ManagedPolicy.fromManagedPolicyArn(this, "NextApiLambdaPolicy", "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole")
            ]
        });
        this.defaultNextLambda = new lambda.Function(this, "NextLambda", {
            functionName: toLambdaOption_1.toLambdaOption("defaultLambda", props.name),
            description: `Default Lambda@Edge for Next CloudFront distribution`,
            handler: "index.handler",
            currentVersionOptions: {
                removalPolicy: core_1.RemovalPolicy.DESTROY // destroy old versions
            },
            logRetention: logs.RetentionDays.THREE_DAYS,
            code: lambda.Code.fromAsset(path.join(this.props.serverlessBuildOutDir, "default-lambda")),
            role: this.edgeLambdaRole,
            runtime: (_a = toLambdaOption_1.toLambdaOption("defaultLambda", props.runtime)) !== null && _a !== void 0 ? _a : lambda.Runtime.NODEJS_12_X,
            memorySize: (_b = toLambdaOption_1.toLambdaOption("defaultLambda", props.memory)) !== null && _b !== void 0 ? _b : 512,
            timeout: (_c = toLambdaOption_1.toLambdaOption("defaultLambda", props.timeout)) !== null && _c !== void 0 ? _c : core_1.Duration.seconds(10)
        });
        this.bucket.grantReadWrite(this.defaultNextLambda);
        this.defaultNextLambda.currentVersion.addAlias("live");
        if (hasISRPages && this.regenerationFunction) {
            this.bucket.grantReadWrite(this.regenerationFunction);
            (_d = this.regenerationQueue) === null || _d === void 0 ? void 0 : _d.grantSendMessages(this.defaultNextLambda);
            (_e = this.regenerationFunction) === null || _e === void 0 ? void 0 : _e.grantInvoke(this.defaultNextLambda);
        }
        const apis = (_f = this.apiBuildManifest) === null || _f === void 0 ? void 0 : _f.apis;
        const hasAPIPages = apis &&
            (Object.keys(apis.nonDynamic).length > 0 ||
                Object.keys(apis.dynamic).length > 0);
        this.nextApiLambda = null;
        if (hasAPIPages) {
            this.nextApiLambda = new lambda.Function(this, "NextApiLambda", {
                functionName: toLambdaOption_1.toLambdaOption("apiLambda", props.name),
                description: `Default Lambda@Edge for Next API CloudFront distribution`,
                handler: "index.handler",
                currentVersionOptions: {
                    removalPolicy: core_1.RemovalPolicy.DESTROY,
                    retryAttempts: 1 // async retry attempts
                },
                logRetention: logs.RetentionDays.THREE_DAYS,
                code: lambda.Code.fromAsset(path.join(this.props.serverlessBuildOutDir, "api-lambda")),
                role: this.edgeLambdaRole,
                runtime: (_g = toLambdaOption_1.toLambdaOption("apiLambda", props.runtime)) !== null && _g !== void 0 ? _g : lambda.Runtime.NODEJS_12_X,
                memorySize: (_h = toLambdaOption_1.toLambdaOption("apiLambda", props.memory)) !== null && _h !== void 0 ? _h : 512,
                timeout: (_j = toLambdaOption_1.toLambdaOption("apiLambda", props.timeout)) !== null && _j !== void 0 ? _j : core_1.Duration.seconds(10)
            });
            this.nextApiLambda.currentVersion.addAlias("live");
        }
        this.nextImageLambda = null;
        if (this.imageManifest) {
            this.nextImageLambda = new lambda.Function(this, "NextImageLambda", {
                functionName: toLambdaOption_1.toLambdaOption("imageLambda", props.name),
                description: `Default Lambda@Edge for Next Image CloudFront distribution`,
                handler: "index.handler",
                currentVersionOptions: {
                    removalPolicy: core_1.RemovalPolicy.DESTROY,
                    retryAttempts: 1 // async retry attempts
                },
                logRetention: logs.RetentionDays.THREE_DAYS,
                code: lambda.Code.fromAsset(path.join(this.props.serverlessBuildOutDir, "image-lambda")),
                role: this.edgeLambdaRole,
                runtime: (_k = toLambdaOption_1.toLambdaOption("imageLambda", props.runtime)) !== null && _k !== void 0 ? _k : lambda.Runtime.NODEJS_12_X,
                memorySize: (_l = toLambdaOption_1.toLambdaOption("imageLambda", props.memory)) !== null && _l !== void 0 ? _l : 512,
                timeout: (_m = toLambdaOption_1.toLambdaOption("imageLambda", props.timeout)) !== null && _m !== void 0 ? _m : core_1.Duration.seconds(10)
            });
            this.nextImageLambda.currentVersion.addAlias("live");
        }
        this.nextStaticsCachePolicy = new cloudfront.CachePolicy(this, "NextStaticsCache", {
            cachePolicyName: (_o = props.cachePolicyName) === null || _o === void 0 ? void 0 : _o.staticsCache,
            queryStringBehavior: cloudfront.CacheQueryStringBehavior.none(),
            headerBehavior: cloudfront.CacheHeaderBehavior.none(),
            cookieBehavior: cloudfront.CacheCookieBehavior.none(),
            defaultTtl: core_1.Duration.days(30),
            maxTtl: core_1.Duration.days(30),
            minTtl: core_1.Duration.days(30),
            enableAcceptEncodingBrotli: true,
            enableAcceptEncodingGzip: true
        });
        this.nextImageCachePolicy = new cloudfront.CachePolicy(this, "NextImageCache", {
            cachePolicyName: (_p = props.cachePolicyName) === null || _p === void 0 ? void 0 : _p.imageCache,
            queryStringBehavior: cloudfront.CacheQueryStringBehavior.all(),
            headerBehavior: cloudfront.CacheHeaderBehavior.allowList("Accept"),
            cookieBehavior: cloudfront.CacheCookieBehavior.none(),
            defaultTtl: core_1.Duration.days(1),
            maxTtl: core_1.Duration.days(365),
            minTtl: core_1.Duration.days(0),
            enableAcceptEncodingBrotli: true,
            enableAcceptEncodingGzip: true
        });
        this.nextLambdaCachePolicy = new cloudfront.CachePolicy(this, "NextLambdaCache", {
            cachePolicyName: (_q = props.cachePolicyName) === null || _q === void 0 ? void 0 : _q.lambdaCache,
            queryStringBehavior: cloudfront.CacheQueryStringBehavior.all(),
            headerBehavior: cloudfront.CacheHeaderBehavior.none(),
            cookieBehavior: {
                behavior: ((_r = props.whiteListedCookies) === null || _r === void 0 ? void 0 : _r.length) ? "whitelist" : "all",
                cookies: props.whiteListedCookies
            },
            defaultTtl: core_1.Duration.seconds(0),
            maxTtl: core_1.Duration.days(365),
            minTtl: core_1.Duration.seconds(0),
            enableAcceptEncodingBrotli: true,
            enableAcceptEncodingGzip: true
        });
        const edgeLambdas = [
            {
                includeBody: true,
                eventType: cloudfront.LambdaEdgeEventType.ORIGIN_REQUEST,
                functionVersion: this.defaultNextLambda.currentVersion
            },
            {
                eventType: cloudfront.LambdaEdgeEventType.ORIGIN_RESPONSE,
                functionVersion: this.defaultNextLambda.currentVersion
            }
        ];
        const _u = props.defaultBehavior || {}, { edgeLambdas: additionalDefaultEdgeLambdas = [] } = _u, defaultBehavior = __rest(_u, ["edgeLambdas"]);
        this.distribution = new cloudfront.Distribution(this, "NextJSDistribution", Object.assign({ enableLogging: props.withLogging ? true : undefined, certificate: (_s = props.domain) === null || _s === void 0 ? void 0 : _s.certificate, domainNames: props.domain ? props.domain.domainNames : undefined, defaultRootObject: "", defaultBehavior: Object.assign({ viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS, origin: new origins.S3Origin(this.bucket), allowedMethods: cloudfront.AllowedMethods.ALLOW_GET_HEAD_OPTIONS, cachedMethods: cloudfront.CachedMethods.CACHE_GET_HEAD_OPTIONS, compress: true, cachePolicy: this.nextLambdaCachePolicy, edgeLambdas: [...edgeLambdas, ...additionalDefaultEdgeLambdas] }, (defaultBehavior || {})), additionalBehaviors: Object.assign(Object.assign(Object.assign(Object.assign({}, (this.nextImageLambda
                ? {
                    [this.pathPattern("_next/image*")]: {
                        viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
                        origin: new origins.S3Origin(this.bucket),
                        allowedMethods: cloudfront.AllowedMethods.ALLOW_ALL,
                        cachedMethods: cloudfront.CachedMethods.CACHE_GET_HEAD_OPTIONS,
                        compress: true,
                        cachePolicy: this.nextImageCachePolicy,
                        originRequestPolicy: new cloudfront.OriginRequestPolicy(this, "ImageOriginRequest", {
                            queryStringBehavior: aws_cloudfront_1.OriginRequestQueryStringBehavior.all()
                        }),
                        edgeLambdas: [
                            {
                                eventType: cloudfront.LambdaEdgeEventType.ORIGIN_REQUEST,
                                functionVersion: this.nextImageLambda.currentVersion
                            }
                        ]
                    }
                }
                : {})), { [this.pathPattern("_next/data/*")]: {
                    viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
                    origin: new origins.S3Origin(this.bucket),
                    allowedMethods: cloudfront.AllowedMethods.ALLOW_GET_HEAD_OPTIONS,
                    cachedMethods: cloudfront.CachedMethods.CACHE_GET_HEAD_OPTIONS,
                    compress: true,
                    cachePolicy: this.nextLambdaCachePolicy,
                    edgeLambdas
                }, [this.pathPattern("_next/*")]: {
                    viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
                    origin: new origins.S3Origin(this.bucket),
                    allowedMethods: cloudfront.AllowedMethods.ALLOW_GET_HEAD_OPTIONS,
                    cachedMethods: cloudfront.CachedMethods.CACHE_GET_HEAD_OPTIONS,
                    compress: true,
                    cachePolicy: this.nextStaticsCachePolicy
                }, [this.pathPattern("static/*")]: {
                    viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
                    origin: new origins.S3Origin(this.bucket),
                    allowedMethods: cloudfront.AllowedMethods.ALLOW_GET_HEAD_OPTIONS,
                    cachedMethods: cloudfront.CachedMethods.CACHE_GET_HEAD_OPTIONS,
                    compress: true,
                    cachePolicy: this.nextStaticsCachePolicy
                } }), (this.nextApiLambda
                ? {
                    [this.pathPattern("api/*")]: {
                        viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
                        origin: new origins.S3Origin(this.bucket),
                        allowedMethods: cloudfront.AllowedMethods.ALLOW_ALL,
                        cachedMethods: cloudfront.CachedMethods.CACHE_GET_HEAD_OPTIONS,
                        compress: true,
                        cachePolicy: this.nextLambdaCachePolicy,
                        edgeLambdas: [
                            {
                                includeBody: true,
                                eventType: cloudfront.LambdaEdgeEventType.ORIGIN_REQUEST,
                                functionVersion: this.nextApiLambda.currentVersion
                            }
                        ]
                    }
                }
                : {})), (props.behaviours || {})) }, (props.cloudfrontProps || {})));
        const assetsDirectory = path.join(props.serverlessBuildOutDir, "assets");
        const assets = readAssetsDirectory_1.readAssetsDirectory({ assetsDirectory });
        // This `BucketDeployment` deploys just the BUILD_ID file. We don't actually
        // use the BUILD_ID file at runtime, however in this case we use it as a
        // file to allow us to create an invalidation of all the routes as evaluated
        // in the function `readInvalidationPathsFromManifest`.
        new s3Deploy.BucketDeployment(this, `AssetDeploymentBuildID`, {
            destinationBucket: this.bucket,
            sources: [
                s3Deploy.Source.asset(assetsDirectory, { exclude: ["**", "!BUILD_ID"] })
            ],
            // This will actually cause the file to exist at BUILD_ID, we do this so
            // that the prune will only prune /BUILD_ID/*, rather than all files fromm
            // the root upwards.
            destinationKeyPrefix: "/BUILD_ID",
            distribution: this.distribution,
            distributionPaths: props.invalidationPaths ||
                reduceInvalidationPaths_1.reduceInvalidationPaths(readInvalidationPathsFromManifest_1.readInvalidationPathsFromManifest(this.defaultManifest))
        });
        Object.keys(assets).forEach((key) => {
            const { path: assetPath, cacheControl } = assets[key];
            new s3Deploy.BucketDeployment(this, `AssetDeployment_${key}`, {
                destinationBucket: this.bucket,
                sources: [s3Deploy.Source.asset(assetPath)],
                cacheControl: [s3Deploy.CacheControl.fromString(cacheControl)],
                // The source contents will be unzipped to and loaded into the S3 bucket
                // at the root '/', we don't want this, we want to maintain the same
                // path on S3 as their local path. Note that this should be a posix path.
                destinationKeyPrefix: pathToPosix_1.default(path.relative(assetsDirectory, assetPath)),
                // Source directories are uploaded with `--sync` this means that any
                // files that don't exist in the source directory, but do in the S3
                // bucket, will be removed.
                prune: true
            });
        });
        if ((_t = props.domain) === null || _t === void 0 ? void 0 : _t.hostedZone) {
            const hostedZone = props.domain.hostedZone;
            props.domain.domainNames.forEach((domainName, index) => {
                this.aRecord = new aws_route53_1.ARecord(this, `AliasRecord_${index}`, {
                    recordName: domainName,
                    zone: hostedZone,
                    target: aws_route53_1.RecordTarget.fromAlias(new aws_route53_targets_1.CloudFrontTarget(this.distribution))
                });
            });
        }
    }
    pathPattern(pattern) {
        const { basePath } = this.routesManifest || {};
        return basePath && basePath.length > 0
            ? `${basePath.slice(1)}/${pattern}`
            : pattern;
    }
    readRoutesManifest() {
        return fs.readJSONSync(path.join(this.props.serverlessBuildOutDir, "default-lambda/routes-manifest.json"));
    }
    readDefaultManifest() {
        return fs.readJSONSync(path.join(this.props.serverlessBuildOutDir, "default-lambda/manifest.json"));
    }
    readPrerenderManifest() {
        return fs.readJSONSync(path.join(this.props.serverlessBuildOutDir, "default-lambda/prerender-manifest.json"));
    }
    readApiBuildManifest() {
        const apiPath = path.join(this.props.serverlessBuildOutDir, "api-lambda/manifest.json");
        if (!fs.existsSync(apiPath))
            return null;
        return fs.readJsonSync(apiPath);
    }
    readImageBuildManifest() {
        const imageLambdaPath = path.join(this.props.serverlessBuildOutDir, "image-lambda/manifest.json");
        return fs.existsSync(imageLambdaPath)
            ? fs.readJSONSync(imageLambdaPath)
            : null;
    }
}
exports.NextJSLambdaEdge = NextJSLambdaEdge;
//# sourceMappingURL=index.js.map