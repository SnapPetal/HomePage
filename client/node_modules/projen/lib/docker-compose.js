"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerComposeProtocol = exports.DockerComposeService = exports.DockerCompose = void 0;
const component_1 = require("./component");
const util_1 = require("./util");
const yaml_1 = require("./yaml");
/**
 * (experimental) Create a docker-compose YAML file.
 *
 * @experimental
 */
class DockerCompose extends component_1.Component {
    /**
     * @experimental
     */
    constructor(project, props) {
        var _a;
        super(project);
        const nameSuffix = (props === null || props === void 0 ? void 0 : props.nameSuffix) ? `${props.nameSuffix}.yml` : 'yml';
        new yaml_1.YamlFile(project, `docker-compose.${nameSuffix}`, {
            committed: true,
            readonly: true,
            obj: () => this._synthesizeDockerCompose(),
        });
        this.services = {};
        // Add the services provided via the constructor argument.
        const initialServices = (_a = props === null || props === void 0 ? void 0 : props.services) !== null && _a !== void 0 ? _a : {};
        for (const [name, serviceDescription] of Object.entries(initialServices)) {
            this.addService(name, serviceDescription);
        }
    }
    /**
     * (experimental) Depends on a service name.
     *
     * @experimental
     */
    static serviceName(serviceName) {
        return {
            serviceName,
        };
    }
    /**
     * (experimental) Create a port mapping.
     *
     * @param publishedPort Published port number.
     * @param targetPort Container's port number.
     * @param options Port mapping options.
     * @experimental
     */
    static portMapping(publishedPort, targetPort, options) {
        var _a;
        const protocol = (_a = options === null || options === void 0 ? void 0 : options.protocol) !== null && _a !== void 0 ? _a : DockerComposeProtocol.TCP;
        return {
            target: targetPort,
            published: publishedPort,
            protocol: protocol,
            mode: 'host',
        };
    }
    /**
     * (experimental) Create a bind volume that binds a host path to the target path in the container.
     *
     * @param sourcePath Host path name.
     * @param targetPath Target path name.
     * @experimental
     */
    static bindVolume(sourcePath, targetPath) {
        return {
            bind(_volumeInfo) {
                return {
                    type: 'bind',
                    source: sourcePath,
                    target: targetPath,
                };
            },
        };
    }
    /**
     * (experimental) Create a named volume and mount it to the target path.
     *
     * If you use this
     * named volume in several services, the volume will be shared. In this
     * case, the volume configuration of the first-provided options are used.
     *
     * @param volumeName Name of the volume.
     * @param targetPath Target path.
     * @param options volume configuration (default: docker compose defaults).
     * @experimental
     */
    static namedVolume(volumeName, targetPath, options = {}) {
        return {
            bind(volumeInfo) {
                volumeInfo.addVolumeConfiguration(volumeName, options);
                return {
                    type: 'volume',
                    source: volumeName,
                    target: targetPath,
                };
            },
        };
    }
    /**
     * (experimental) Add a service to the docker-compose file.
     *
     * @param serviceName name of the service.
     * @param description a service description.
     * @experimental
     */
    addService(serviceName, description) {
        const service = new DockerComposeService(serviceName, description);
        this.services[serviceName] = service;
        return service;
    }
    /**
     * @internal
     */
    _synthesizeDockerCompose() {
        if (Object.keys(this.services).length === 0) {
            throw new Error('DockerCompose requires at least one service');
        }
        return renderDockerComposeFile(this.services);
    }
}
exports.DockerCompose = DockerCompose;
/**
 * (experimental) A docker-compose service.
 *
 * @experimental
 */
class DockerComposeService {
    /**
     * @experimental
     */
    constructor(serviceName, serviceDescription) {
        var _a, _b, _c, _d;
        if ((!serviceDescription.imageBuild && !serviceDescription.image)
            || (serviceDescription.imageBuild && serviceDescription.image)) {
            throw new Error(`A service ${serviceName} requires exactly one of a \`imageBuild\` or \`image\` key`);
        }
        this.serviceName = serviceName;
        this.command = serviceDescription.command;
        this.image = serviceDescription.image;
        this.imageBuild = serviceDescription.imageBuild;
        this.dependsOn = (_a = serviceDescription.dependsOn) !== null && _a !== void 0 ? _a : [];
        this.volumes = (_b = serviceDescription.volumes) !== null && _b !== void 0 ? _b : [];
        this.ports = (_c = serviceDescription.ports) !== null && _c !== void 0 ? _c : [];
        this.environment = (_d = serviceDescription.environment) !== null && _d !== void 0 ? _d : {};
    }
    /**
     * (experimental) Add a port mapping.
     *
     * @param publishedPort Published port number.
     * @param targetPort Container's port number.
     * @param options Port mapping options.
     * @experimental
     */
    addPort(publishedPort, targetPort, options) {
        var _a;
        (_a = this.ports) === null || _a === void 0 ? void 0 : _a.push(DockerCompose.portMapping(publishedPort, targetPort, options));
    }
    /**
     * (experimental) Add an environment variable.
     *
     * @param name environment variable name.
     * @param value value of the environment variable.
     * @experimental
     */
    addEnvironment(name, value) {
        this.environment[name] = value;
    }
    /**
     * (experimental) Make the service depend on another service.
     *
     * @experimental
     */
    addDependsOn(serviceName) {
        this.dependsOn.push(serviceName);
    }
    /**
     * (experimental) Add a volume to the service.
     *
     * @experimental
     */
    addVolume(volume) {
        this.volumes.push(volume);
    }
}
exports.DockerComposeService = DockerComposeService;
/**
 * (experimental) Network protocol for port mapping.
 *
 * @experimental
 */
var DockerComposeProtocol;
(function (DockerComposeProtocol) {
    DockerComposeProtocol["TCP"] = "tcp";
    DockerComposeProtocol["UDP"] = "udp";
})(DockerComposeProtocol = exports.DockerComposeProtocol || (exports.DockerComposeProtocol = {}));
function renderDockerComposeFile(serviceDescriptions) {
    var _a, _b;
    // Record volume configuration
    const volumeConfig = {};
    const volumeInfo = {
        addVolumeConfiguration(volumeName, configuration) {
            if (!volumeConfig[volumeName]) {
                // First volume configuration takes precedence.
                volumeConfig[volumeName] = configuration;
            }
        },
    };
    // Render service configuration
    const services = {};
    for (const [serviceName, serviceDescription] of Object.entries(serviceDescriptions !== null && serviceDescriptions !== void 0 ? serviceDescriptions : {})) {
        // Resolve the names of each dependency and check that they exist.
        // Note: They may not exist if the user made a mistake when referencing a
        // service by name via `DockerCompose.serviceName()`.
        // @see DockerCompose.serviceName
        const dependsOn = Array();
        for (const dependsOnServiceName of (_a = serviceDescription.dependsOn) !== null && _a !== void 0 ? _a : []) {
            const resolvedServiceName = dependsOnServiceName.serviceName;
            if (resolvedServiceName === serviceName) {
                throw new Error(`Service ${serviceName} cannot depend on itself`);
            }
            if (!serviceDescriptions[resolvedServiceName]) {
                throw new Error(`Unable to resolve service named ${resolvedServiceName} for ${serviceName}`);
            }
            dependsOn.push(resolvedServiceName);
        }
        // Give each volume binding a chance to bind any necessary volume
        // configuration and provide volume mount information for the service.
        const volumes = [];
        for (const volumeBinding of (_b = serviceDescription.volumes) !== null && _b !== void 0 ? _b : []) {
            volumes.push(volumeBinding.bind(volumeInfo));
        }
        // Create and store the service configuration, taking care not to create
        // object members with undefined values.
        services[serviceName] = {
            ...getObjectWithKeyAndValueIfValueIsDefined('image', serviceDescription.image),
            ...getObjectWithKeyAndValueIfValueIsDefined('build', serviceDescription.imageBuild),
            ...getObjectWithKeyAndValueIfValueIsDefined('command', serviceDescription.command),
            ...(Object.keys(serviceDescription.environment).length > 0 ? { environment: serviceDescription.environment } : {}),
            ...(serviceDescription.ports.length > 0 ? { ports: serviceDescription.ports } : {}),
            ...(dependsOn.length > 0 ? { dependsOn } : {}),
            ...(volumes.length > 0 ? { volumes } : {}),
        };
    }
    // Explicit with the type here because the decamelize step after this wipes
    // out types.
    const input = {
        services,
        ...(Object.keys(volumeConfig).length > 0 ? { volumes: volumeConfig } : {}),
    };
    // Change most keys to snake case.
    return util_1.decamelizeKeysRecursively(input, {
        shouldDecamelize: shouldDecamelizeDockerComposeKey,
        separator: '_',
    });
}
/**
 * Returns `{ [key]: value }` if `value` is defined, otherwise returns `{}` so
 * that object spreading can be used to generate a peculiar interface.
 * @param key
 * @param value
 */
function getObjectWithKeyAndValueIfValueIsDefined(key, value) {
    return value !== undefined ? { [key]: value } : {};
}
/**
 * Determines whether the key at the given path should be decamelized.
 * Largely, all keys should be snake cased. But, there are some
 * exceptions for user-provided names for services, volumes, and
 * environment variables.
 *
 * @param path
 */
function shouldDecamelizeDockerComposeKey(path) {
    const poundPath = path.join('#');
    // Does not decamelize user's names.
    // services.namehere:
    // volumes.namehere:
    if (/^(services|volumes)#[^#]+$/.test(poundPath)) {
        return false;
    }
    // Does not decamelize environment variables
    // services.namehere.environment.*
    if (/^services#[^#]+#environment#/.test(poundPath)) {
        return false;
    }
    // Does not decamelize build arguments
    // services.namehere.build.args.*
    if (/^services#[^#]+#build#args#/.test(poundPath)) {
        return false;
    }
    // Otherwise, let it all decamelize.
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9ja2VyLWNvbXBvc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvZG9ja2VyLWNvbXBvc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMkNBQXdDO0FBRXhDLGlDQUFtRDtBQUNuRCxpQ0FBa0M7Ozs7OztBQWlDbEMsTUFBYSxhQUFjLFNBQVEscUJBQVM7Ozs7SUFxRTFDLFlBQVksT0FBZ0IsRUFBRSxLQUEwQjs7UUFDdEQsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRWYsTUFBTSxVQUFVLEdBQUcsQ0FBQSxLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUsVUFBVSxFQUFDLENBQUMsQ0FBQyxHQUFHLEtBQU0sQ0FBQyxVQUFVLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO1FBQzFFLElBQUksZUFBUSxDQUFDLE9BQU8sRUFBRSxrQkFBa0IsVUFBVSxFQUFFLEVBQUU7WUFDcEQsU0FBUyxFQUFFLElBQUk7WUFDZixRQUFRLEVBQUUsSUFBSTtZQUNkLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEVBQUU7U0FDM0MsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7UUFFbkIsMERBQTBEO1FBQzFELE1BQU0sZUFBZSxTQUFHLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxRQUFRLG1DQUFJLEVBQUUsQ0FBQztRQUM5QyxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsa0JBQWtCLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxFQUFFO1lBQ3hFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLGtCQUFrQixDQUFDLENBQUM7U0FDM0M7SUFDSCxDQUFDOzs7Ozs7SUFsRkQsTUFBTSxDQUFDLFdBQVcsQ0FBQyxXQUFtQjtRQUNwQyxPQUFPO1lBQ0wsV0FBVztTQUNaLENBQUM7SUFDSixDQUFDOzs7Ozs7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d0NBQXdDLENBQXNCLEdBQU0sRUFBRSxLQUFRO0lBQ3JGLE9BQU8sS0FBSyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDckQsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFTLGdDQUFnQyxDQUFDLElBQWM7SUFDdEQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUVqQyxvQ0FBb0M7SUFDcEMscUJBQXFCO0lBQ3JCLG9CQUFvQjtJQUNwQixJQUFJLDRCQUE0QixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUNoRCxPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsNENBQTRDO0lBQzVDLGtDQUFrQztJQUNsQyxJQUFJLDhCQUE4QixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUNsRCxPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsc0NBQXNDO0lBQ3RDLGlDQUFpQztJQUNqQyxJQUFJLDZCQUE2QixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUNqRCxPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsb0NBQW9DO0lBQ3BDLE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50JztcbmltcG9ydCB7IFByb2plY3QgfSBmcm9tICcuL3Byb2plY3QnO1xuaW1wb3J0IHsgZGVjYW1lbGl6ZUtleXNSZWN1cnNpdmVseSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBZYW1sRmlsZSB9IGZyb20gJy4veWFtbCc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5leHBvcnQgaW50ZXJmYWNlIERvY2tlckNvbXBvc2VQcm9wcyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IG5hbWVTdWZmaXg/OiBzdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IHNlcnZpY2VzPzogUmVjb3JkPHN0cmluZywgRG9ja2VyQ29tcG9zZVNlcnZpY2VEZXNjcmlwdGlvbj47XG59XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmV4cG9ydCBpbnRlcmZhY2UgRG9ja2VyQ29tcG9zZVBvcnRNYXBwaW5nT3B0aW9ucyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IHByb3RvY29sPzogRG9ja2VyQ29tcG9zZVByb3RvY29sO1xufVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmV4cG9ydCBjbGFzcyBEb2NrZXJDb21wb3NlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgc3RhdGljIHNlcnZpY2VOYW1lKHNlcnZpY2VOYW1lOiBzdHJpbmcpOiBJRG9ja2VyQ29tcG9zZVNlcnZpY2VOYW1lIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VydmljZU5hbWUsXG4gICAgfTtcbiAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHN0YXRpYyBwb3J0TWFwcGluZyhwdWJsaXNoZWRQb3J0OiBudW1iZXIsIHRhcmdldFBvcnQ6IG51bWJlciwgb3B0aW9ucz86IERvY2tlckNvbXBvc2VQb3J0TWFwcGluZ09wdGlvbnMpOiBEb2NrZXJDb21wb3NlU2VydmljZVBvcnQge1xuICAgIGNvbnN0IHByb3RvY29sID0gb3B0aW9ucz8ucHJvdG9jb2wgPz8gRG9ja2VyQ29tcG9zZVByb3RvY29sLlRDUDtcblxuICAgIHJldHVybiB7XG4gICAgICB0YXJnZXQ6IHRhcmdldFBvcnQsXG4gICAgICBwdWJsaXNoZWQ6IHB1Ymxpc2hlZFBvcnQsXG4gICAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgICBtb2RlOiAnaG9zdCcsXG4gICAgfTtcbiAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHN0YXRpYyBiaW5kVm9sdW1lKHNvdXJjZVBhdGg6IHN0cmluZywgdGFyZ2V0UGF0aDogc3RyaW5nKTogSURvY2tlckNvbXBvc2VWb2x1bWVCaW5kaW5nIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmluZChfdm9sdW1lSW5mbzogSURvY2tlckNvbXBvc2VWb2x1bWVDb25maWcpOiBEb2NrZXJDb21wb3NlVm9sdW1lTW91bnQge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdiaW5kJyxcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZVBhdGgsXG4gICAgICAgICAgdGFyZ2V0OiB0YXJnZXRQYXRoLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHN0YXRpYyBuYW1lZFZvbHVtZSh2b2x1bWVOYW1lOiBzdHJpbmcsIHRhcmdldFBhdGg6IHN0cmluZywgb3B0aW9uczogRG9ja2VyQ29tcG9zZVZvbHVtZUNvbmZpZyA9IHt9KTogSURvY2tlckNvbXBvc2VWb2x1bWVCaW5kaW5nIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmluZCh2b2x1bWVJbmZvOiBJRG9ja2VyQ29tcG9zZVZvbHVtZUNvbmZpZyk6IERvY2tlckNvbXBvc2VWb2x1bWVNb3VudCB7XG4gICAgICAgIHZvbHVtZUluZm8uYWRkVm9sdW1lQ29uZmlndXJhdGlvbih2b2x1bWVOYW1lLCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICd2b2x1bWUnLFxuICAgICAgICAgIHNvdXJjZTogdm9sdW1lTmFtZSxcbiAgICAgICAgICB0YXJnZXQ6IHRhcmdldFBhdGgsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IHNlcnZpY2VzOiBSZWNvcmQ8c3RyaW5nLCBEb2NrZXJDb21wb3NlU2VydmljZT47XG5cbiAgY29uc3RydWN0b3IocHJvamVjdDogUHJvamVjdCwgcHJvcHM/OiBEb2NrZXJDb21wb3NlUHJvcHMpIHtcbiAgICBzdXBlcihwcm9qZWN0KTtcblxuICAgIGNvbnN0IG5hbWVTdWZmaXggPSBwcm9wcz8ubmFtZVN1ZmZpeCA/IGAke3Byb3BzIS5uYW1lU3VmZml4fS55bWxgIDogJ3ltbCc7XG4gICAgbmV3IFlhbWxGaWxlKHByb2plY3QsIGBkb2NrZXItY29tcG9zZS4ke25hbWVTdWZmaXh9YCwge1xuICAgICAgY29tbWl0dGVkOiB0cnVlLFxuICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICBvYmo6ICgpID0+IHRoaXMuX3N5bnRoZXNpemVEb2NrZXJDb21wb3NlKCksXG4gICAgfSk7XG5cbiAgICB0aGlzLnNlcnZpY2VzID0ge307XG5cbiAgICAvLyBBZGQgdGhlIHNlcnZpY2VzIHByb3ZpZGVkIHZpYSB0aGUgY29uc3RydWN0b3IgYXJndW1lbnQuXG4gICAgY29uc3QgaW5pdGlhbFNlcnZpY2VzID0gcHJvcHM/LnNlcnZpY2VzID8/IHt9O1xuICAgIGZvciAoY29uc3QgW25hbWUsIHNlcnZpY2VEZXNjcmlwdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoaW5pdGlhbFNlcnZpY2VzKSkge1xuICAgICAgdGhpcy5hZGRTZXJ2aWNlKG5hbWUsIHNlcnZpY2VEZXNjcmlwdGlvbik7XG4gICAgfVxuICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIGFkZFNlcnZpY2Uoc2VydmljZU5hbWU6IHN0cmluZywgZGVzY3JpcHRpb246IERvY2tlckNvbXBvc2VTZXJ2aWNlRGVzY3JpcHRpb24pOiBEb2NrZXJDb21wb3NlU2VydmljZSB7XG4gICAgY29uc3Qgc2VydmljZSA9IG5ldyBEb2NrZXJDb21wb3NlU2VydmljZShzZXJ2aWNlTmFtZSwgZGVzY3JpcHRpb24pO1xuICAgIHRoaXMuc2VydmljZXNbc2VydmljZU5hbWVdID0gc2VydmljZTtcbiAgICByZXR1cm4gc2VydmljZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zeW50aGVzaXplRG9ja2VyQ29tcG9zZSgpOiBvYmplY3Qge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnNlcnZpY2VzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRG9ja2VyQ29tcG9zZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgc2VydmljZScpO1xuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJEb2NrZXJDb21wb3NlRmlsZSh0aGlzLnNlcnZpY2VzKTtcbiAgfVxufVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuZXhwb3J0IGludGVyZmFjZSBJRG9ja2VyQ29tcG9zZVNlcnZpY2VOYW1lIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IHNlcnZpY2VOYW1lOiBzdHJpbmc7XG59XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmV4cG9ydCBpbnRlcmZhY2UgRG9ja2VyQ29tcG9zZVNlcnZpY2VEZXNjcmlwdGlvbiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSBpbWFnZT86IHN0cmluZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSBpbWFnZUJ1aWxkPzogRG9ja2VyQ29tcG9zZUJ1aWxkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgY29tbWFuZD86IHN0cmluZ1tdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IGRlcGVuZHNPbj86IElEb2NrZXJDb21wb3NlU2VydmljZU5hbWVbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IHZvbHVtZXM/OiBJRG9ja2VyQ29tcG9zZVZvbHVtZUJpbmRpbmdbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgcG9ydHM/OiBEb2NrZXJDb21wb3NlU2VydmljZVBvcnRbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSBlbnZpcm9ubWVudD86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuZXhwb3J0IGNsYXNzIERvY2tlckNvbXBvc2VTZXJ2aWNlIGltcGxlbWVudHMgSURvY2tlckNvbXBvc2VTZXJ2aWNlTmFtZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHB1YmxpYyByZWFkb25seSBzZXJ2aWNlTmFtZTogc3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIHJlYWRvbmx5IGltYWdlPzogc3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHB1YmxpYyByZWFkb25seSBpbWFnZUJ1aWxkPzogRG9ja2VyQ29tcG9zZUJ1aWxkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHB1YmxpYyByZWFkb25seSBjb21tYW5kPzogc3RyaW5nW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIHJlYWRvbmx5IGRlcGVuZHNPbjogSURvY2tlckNvbXBvc2VTZXJ2aWNlTmFtZVtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwdWJsaWMgcmVhZG9ubHkgdm9sdW1lczogSURvY2tlckNvbXBvc2VWb2x1bWVCaW5kaW5nW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwdWJsaWMgcmVhZG9ubHkgcG9ydHM6IERvY2tlckNvbXBvc2VTZXJ2aWNlUG9ydFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIHJlYWRvbmx5IGVudmlyb25tZW50OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG4gIGNvbnN0cnVjdG9yKHNlcnZpY2VOYW1lOiBzdHJpbmcsIHNlcnZpY2VEZXNjcmlwdGlvbjogRG9ja2VyQ29tcG9zZVNlcnZpY2VEZXNjcmlwdGlvbikge1xuICAgIGlmICgoIXNlcnZpY2VEZXNjcmlwdGlvbi5pbWFnZUJ1aWxkICYmICFzZXJ2aWNlRGVzY3JpcHRpb24uaW1hZ2UpXG4gICAgICB8fCAoc2VydmljZURlc2NyaXB0aW9uLmltYWdlQnVpbGQgJiYgc2VydmljZURlc2NyaXB0aW9uLmltYWdlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIHNlcnZpY2UgJHtzZXJ2aWNlTmFtZX0gcmVxdWlyZXMgZXhhY3RseSBvbmUgb2YgYSBcXGBpbWFnZUJ1aWxkXFxgIG9yIFxcYGltYWdlXFxgIGtleWApO1xuICAgIH1cblxuICAgIHRoaXMuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcbiAgICB0aGlzLmNvbW1hbmQgPSBzZXJ2aWNlRGVzY3JpcHRpb24uY29tbWFuZDtcbiAgICB0aGlzLmltYWdlID0gc2VydmljZURlc2NyaXB0aW9uLmltYWdlO1xuICAgIHRoaXMuaW1hZ2VCdWlsZCA9IHNlcnZpY2VEZXNjcmlwdGlvbi5pbWFnZUJ1aWxkO1xuICAgIHRoaXMuZGVwZW5kc09uID0gc2VydmljZURlc2NyaXB0aW9uLmRlcGVuZHNPbiA/PyBbXTtcbiAgICB0aGlzLnZvbHVtZXMgPSBzZXJ2aWNlRGVzY3JpcHRpb24udm9sdW1lcyA/PyBbXTtcbiAgICB0aGlzLnBvcnRzID0gc2VydmljZURlc2NyaXB0aW9uLnBvcnRzID8/IFtdO1xuICAgIHRoaXMuZW52aXJvbm1lbnQgPSBzZXJ2aWNlRGVzY3JpcHRpb24uZW52aXJvbm1lbnQgPz8ge307XG4gIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHB1YmxpYyBhZGRQb3J0KHB1Ymxpc2hlZFBvcnQ6IG51bWJlciwgdGFyZ2V0UG9ydDogbnVtYmVyLCBvcHRpb25zPzogRG9ja2VyQ29tcG9zZVBvcnRNYXBwaW5nT3B0aW9ucykge1xuICAgIHRoaXMucG9ydHM/LnB1c2goRG9ja2VyQ29tcG9zZS5wb3J0TWFwcGluZyhwdWJsaXNoZWRQb3J0LCB0YXJnZXRQb3J0LCBvcHRpb25zKSk7XG4gIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwdWJsaWMgYWRkRW52aXJvbm1lbnQobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5lbnZpcm9ubWVudFtuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwdWJsaWMgYWRkRGVwZW5kc09uKHNlcnZpY2VOYW1lOiBJRG9ja2VyQ29tcG9zZVNlcnZpY2VOYW1lKSB7XG4gICAgdGhpcy5kZXBlbmRzT24ucHVzaChzZXJ2aWNlTmFtZSk7XG4gIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwdWJsaWMgYWRkVm9sdW1lKHZvbHVtZTogSURvY2tlckNvbXBvc2VWb2x1bWVCaW5kaW5nKSB7XG4gICAgdGhpcy52b2x1bWVzLnB1c2godm9sdW1lKTtcbiAgfVxufVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmV4cG9ydCBpbnRlcmZhY2UgRG9ja2VyQ29tcG9zZVNlcnZpY2VQb3J0IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IHB1Ymxpc2hlZDogbnVtYmVyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSB0YXJnZXQ6IG51bWJlcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IHByb3RvY29sOiBEb2NrZXJDb21wb3NlUHJvdG9jb2w7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IG1vZGU6IHN0cmluZztcbn1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmV4cG9ydCBlbnVtIERvY2tlckNvbXBvc2VQcm90b2NvbCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBUQ1AgPSAndGNwJyxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgVURQID0gJ3VkcCcsXG59XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmV4cG9ydCBpbnRlcmZhY2UgRG9ja2VyQ29tcG9zZUJ1aWxkIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSBjb250ZXh0OiBzdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IGRvY2tlcmZpbGU/OiBzdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHJlYWRvbmx5IGFyZ3M/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5leHBvcnQgaW50ZXJmYWNlIERvY2tlckNvbXBvc2VWb2x1bWVDb25maWcge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgZHJpdmVyPzogc3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSBkcml2ZXJPcHRzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgZXh0ZXJuYWw/OiBib29sZWFuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbn1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmV4cG9ydCBpbnRlcmZhY2UgSURvY2tlckNvbXBvc2VWb2x1bWVCaW5kaW5nIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBiaW5kKHZvbHVtZUNvbmZpZzogSURvY2tlckNvbXBvc2VWb2x1bWVDb25maWcpOiBEb2NrZXJDb21wb3NlVm9sdW1lTW91bnQ7XG59XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5leHBvcnQgaW50ZXJmYWNlIElEb2NrZXJDb21wb3NlVm9sdW1lQ29uZmlnIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgYWRkVm9sdW1lQ29uZmlndXJhdGlvbih2b2x1bWVOYW1lOiBzdHJpbmcsIGNvbmZpZ3VyYXRpb246IERvY2tlckNvbXBvc2VWb2x1bWVDb25maWcpOiB2b2lkO1xufVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuZXhwb3J0IGludGVyZmFjZSBEb2NrZXJDb21wb3NlVm9sdW1lTW91bnQge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcmVhZG9ubHkgc291cmNlOiBzdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICByZWFkb25seSB0YXJnZXQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBTdHJ1Y3R1cmUgb2YgYSBkb2NrZXIgY29tcG9zZSBmaWxlIGJlZm9yZSB3ZSBkZWNhbWVsaXplLlxuICogQGludGVybmFsXG4gKi9cbmludGVyZmFjZSBEb2NrZXJDb21wb3NlRmlsZVNjaGVtYSB7XG4gIHNlcnZpY2VzOiBSZWNvcmQ8c3RyaW5nLCBEb2NrZXJDb21wb3NlRmlsZVNlcnZpY2VTY2hlbWE+O1xuICB2b2x1bWVzPzogUmVjb3JkPHN0cmluZywgRG9ja2VyQ29tcG9zZVZvbHVtZUNvbmZpZz47XG59XG5cbi8qKlxuICogU3RydWN0dXJlIG9mIGEgZG9ja2VyIGNvbXBvc2UgZmlsZSdzIHNlcnZpY2UgYmVmb3JlIHdlIGRlY2FtZWxpemUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuaW50ZXJmYWNlIERvY2tlckNvbXBvc2VGaWxlU2VydmljZVNjaGVtYSB7XG4gIHJlYWRvbmx5IGRlcGVuZHNPbj86IHN0cmluZ1tdO1xuICByZWFkb25seSBidWlsZD86IERvY2tlckNvbXBvc2VCdWlsZDtcbiAgcmVhZG9ubHkgaW1hZ2U/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNvbW1hbmQ/OiBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgdm9sdW1lcz86IERvY2tlckNvbXBvc2VWb2x1bWVNb3VudFtdO1xuICByZWFkb25seSBwb3J0cz86IERvY2tlckNvbXBvc2VTZXJ2aWNlUG9ydFtdO1xuICByZWFkb25seSBlbnZpcm9ubWVudD86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59XG5cbmZ1bmN0aW9uIHJlbmRlckRvY2tlckNvbXBvc2VGaWxlKHNlcnZpY2VEZXNjcmlwdGlvbnM6IFJlY29yZDxzdHJpbmcsIERvY2tlckNvbXBvc2VTZXJ2aWNlPik6IG9iamVjdCB7XG4gIC8vIFJlY29yZCB2b2x1bWUgY29uZmlndXJhdGlvblxuICBjb25zdCB2b2x1bWVDb25maWc6IFJlY29yZDxzdHJpbmcsIERvY2tlckNvbXBvc2VWb2x1bWVDb25maWc+ID0ge307XG4gIGNvbnN0IHZvbHVtZUluZm86IElEb2NrZXJDb21wb3NlVm9sdW1lQ29uZmlnID0ge1xuICAgIGFkZFZvbHVtZUNvbmZpZ3VyYXRpb24odm9sdW1lTmFtZTogc3RyaW5nLCBjb25maWd1cmF0aW9uOiBEb2NrZXJDb21wb3NlVm9sdW1lQ29uZmlnKSB7XG4gICAgICBpZiAoIXZvbHVtZUNvbmZpZ1t2b2x1bWVOYW1lXSkge1xuICAgICAgICAvLyBGaXJzdCB2b2x1bWUgY29uZmlndXJhdGlvbiB0YWtlcyBwcmVjZWRlbmNlLlxuICAgICAgICB2b2x1bWVDb25maWdbdm9sdW1lTmFtZV0gPSBjb25maWd1cmF0aW9uO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbiAgLy8gUmVuZGVyIHNlcnZpY2UgY29uZmlndXJhdGlvblxuICBjb25zdCBzZXJ2aWNlczogUmVjb3JkPHN0cmluZywgRG9ja2VyQ29tcG9zZUZpbGVTZXJ2aWNlU2NoZW1hPiA9IHt9O1xuICBmb3IgKGNvbnN0IFtzZXJ2aWNlTmFtZSwgc2VydmljZURlc2NyaXB0aW9uXSBvZiBPYmplY3QuZW50cmllcyhzZXJ2aWNlRGVzY3JpcHRpb25zID8/IHt9KSkge1xuICAgIC8vIFJlc29sdmUgdGhlIG5hbWVzIG9mIGVhY2ggZGVwZW5kZW5jeSBhbmQgY2hlY2sgdGhhdCB0aGV5IGV4aXN0LlxuICAgIC8vIE5vdGU6IFRoZXkgbWF5IG5vdCBleGlzdCBpZiB0aGUgdXNlciBtYWRlIGEgbWlzdGFrZSB3aGVuIHJlZmVyZW5jaW5nIGFcbiAgICAvLyBzZXJ2aWNlIGJ5IG5hbWUgdmlhIGBEb2NrZXJDb21wb3NlLnNlcnZpY2VOYW1lKClgLlxuICAgIC8vIEBzZWUgRG9ja2VyQ29tcG9zZS5zZXJ2aWNlTmFtZVxuICAgIGNvbnN0IGRlcGVuZHNPbiA9IEFycmF5PHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IGRlcGVuZHNPblNlcnZpY2VOYW1lIG9mIHNlcnZpY2VEZXNjcmlwdGlvbi5kZXBlbmRzT24gPz8gW10pIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkU2VydmljZU5hbWUgPSBkZXBlbmRzT25TZXJ2aWNlTmFtZS5zZXJ2aWNlTmFtZTtcbiAgICAgIGlmIChyZXNvbHZlZFNlcnZpY2VOYW1lID09PSBzZXJ2aWNlTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZpY2UgJHtzZXJ2aWNlTmFtZX0gY2Fubm90IGRlcGVuZCBvbiBpdHNlbGZgKTtcbiAgICAgIH1cbiAgICAgIGlmICghc2VydmljZURlc2NyaXB0aW9uc1tyZXNvbHZlZFNlcnZpY2VOYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIHNlcnZpY2UgbmFtZWQgJHtyZXNvbHZlZFNlcnZpY2VOYW1lfSBmb3IgJHtzZXJ2aWNlTmFtZX1gKTtcbiAgICAgIH1cblxuICAgICAgZGVwZW5kc09uLnB1c2gocmVzb2x2ZWRTZXJ2aWNlTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gR2l2ZSBlYWNoIHZvbHVtZSBiaW5kaW5nIGEgY2hhbmNlIHRvIGJpbmQgYW55IG5lY2Vzc2FyeSB2b2x1bWVcbiAgICAvLyBjb25maWd1cmF0aW9uIGFuZCBwcm92aWRlIHZvbHVtZSBtb3VudCBpbmZvcm1hdGlvbiBmb3IgdGhlIHNlcnZpY2UuXG4gICAgY29uc3Qgdm9sdW1lczogRG9ja2VyQ29tcG9zZVZvbHVtZU1vdW50W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZvbHVtZUJpbmRpbmcgb2Ygc2VydmljZURlc2NyaXB0aW9uLnZvbHVtZXMgPz8gW10pIHtcbiAgICAgIHZvbHVtZXMucHVzaCh2b2x1bWVCaW5kaW5nLmJpbmQodm9sdW1lSW5mbykpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhbmQgc3RvcmUgdGhlIHNlcnZpY2UgY29uZmlndXJhdGlvbiwgdGFraW5nIGNhcmUgbm90IHRvIGNyZWF0ZVxuICAgIC8vIG9iamVjdCBtZW1iZXJzIHdpdGggdW5kZWZpbmVkIHZhbHVlcy5cbiAgICBzZXJ2aWNlc1tzZXJ2aWNlTmFtZV0gPSB7XG4gICAgICAuLi5nZXRPYmplY3RXaXRoS2V5QW5kVmFsdWVJZlZhbHVlSXNEZWZpbmVkKCdpbWFnZScsIHNlcnZpY2VEZXNjcmlwdGlvbi5pbWFnZSksXG4gICAgICAuLi5nZXRPYmplY3RXaXRoS2V5QW5kVmFsdWVJZlZhbHVlSXNEZWZpbmVkKCdidWlsZCcsIHNlcnZpY2VEZXNjcmlwdGlvbi5pbWFnZUJ1aWxkKSxcbiAgICAgIC4uLmdldE9iamVjdFdpdGhLZXlBbmRWYWx1ZUlmVmFsdWVJc0RlZmluZWQoJ2NvbW1hbmQnLCBzZXJ2aWNlRGVzY3JpcHRpb24uY29tbWFuZCksXG4gICAgICAuLi4oT2JqZWN0LmtleXMoc2VydmljZURlc2NyaXB0aW9uLmVudmlyb25tZW50KS5sZW5ndGggPiAwID8geyBlbnZpcm9ubWVudDogc2VydmljZURlc2NyaXB0aW9uLmVudmlyb25tZW50IH0gOiB7fSksXG4gICAgICAuLi4oc2VydmljZURlc2NyaXB0aW9uLnBvcnRzLmxlbmd0aCA+IDAgPyB7IHBvcnRzOiBzZXJ2aWNlRGVzY3JpcHRpb24ucG9ydHMgfSA6IHt9KSxcbiAgICAgIC4uLihkZXBlbmRzT24ubGVuZ3RoID4gMCA/IHsgZGVwZW5kc09uIH0gOiB7fSksXG4gICAgICAuLi4odm9sdW1lcy5sZW5ndGggPiAwID8geyB2b2x1bWVzIH0gOiB7fSksXG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cGxpY2l0IHdpdGggdGhlIHR5cGUgaGVyZSBiZWNhdXNlIHRoZSBkZWNhbWVsaXplIHN0ZXAgYWZ0ZXIgdGhpcyB3aXBlc1xuICAvLyBvdXQgdHlwZXMuXG4gIGNvbnN0IGlucHV0OiBEb2NrZXJDb21wb3NlRmlsZVNjaGVtYSA9IHtcbiAgICBzZXJ2aWNlcyxcbiAgICAuLi4oT2JqZWN0LmtleXModm9sdW1lQ29uZmlnKS5sZW5ndGggPiAwID8geyB2b2x1bWVzOiB2b2x1bWVDb25maWcgfSA6IHt9KSxcbiAgfTtcblxuICAvLyBDaGFuZ2UgbW9zdCBrZXlzIHRvIHNuYWtlIGNhc2UuXG4gIHJldHVybiBkZWNhbWVsaXplS2V5c1JlY3Vyc2l2ZWx5KGlucHV0LCB7XG4gICAgc2hvdWxkRGVjYW1lbGl6ZTogc2hvdWxkRGVjYW1lbGl6ZURvY2tlckNvbXBvc2VLZXksXG4gICAgc2VwYXJhdG9yOiAnXycsXG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYHsgW2tleV06IHZhbHVlIH1gIGlmIGB2YWx1ZWAgaXMgZGVmaW5lZCwgb3RoZXJ3aXNlIHJldHVybnMgYHt9YCBzb1xuICogdGhhdCBvYmplY3Qgc3ByZWFkaW5nIGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIGEgcGVjdWxpYXIgaW50ZXJmYWNlLlxuICogQHBhcmFtIGtleVxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldE9iamVjdFdpdGhLZXlBbmRWYWx1ZUlmVmFsdWVJc0RlZmluZWQ8SyBleHRlbmRzIHN0cmluZywgVD4oa2V5OiBLLCB2YWx1ZTogVCk6IHsgSzogVCB9IHwge30ge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHsgW2tleV06IHZhbHVlIH0gOiB7fTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGtleSBhdCB0aGUgZ2l2ZW4gcGF0aCBzaG91bGQgYmUgZGVjYW1lbGl6ZWQuXG4gKiBMYXJnZWx5LCBhbGwga2V5cyBzaG91bGQgYmUgc25ha2UgY2FzZWQuIEJ1dCwgdGhlcmUgYXJlIHNvbWVcbiAqIGV4Y2VwdGlvbnMgZm9yIHVzZXItcHJvdmlkZWQgbmFtZXMgZm9yIHNlcnZpY2VzLCB2b2x1bWVzLCBhbmRcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICovXG5mdW5jdGlvbiBzaG91bGREZWNhbWVsaXplRG9ja2VyQ29tcG9zZUtleShwYXRoOiBzdHJpbmdbXSkge1xuICBjb25zdCBwb3VuZFBhdGggPSBwYXRoLmpvaW4oJyMnKTtcblxuICAvLyBEb2VzIG5vdCBkZWNhbWVsaXplIHVzZXIncyBuYW1lcy5cbiAgLy8gc2VydmljZXMubmFtZWhlcmU6XG4gIC8vIHZvbHVtZXMubmFtZWhlcmU6XG4gIGlmICgvXihzZXJ2aWNlc3x2b2x1bWVzKSNbXiNdKyQvLnRlc3QocG91bmRQYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIERvZXMgbm90IGRlY2FtZWxpemUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gIC8vIHNlcnZpY2VzLm5hbWVoZXJlLmVudmlyb25tZW50LipcbiAgaWYgKC9ec2VydmljZXMjW14jXSsjZW52aXJvbm1lbnQjLy50ZXN0KHBvdW5kUGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBEb2VzIG5vdCBkZWNhbWVsaXplIGJ1aWxkIGFyZ3VtZW50c1xuICAvLyBzZXJ2aWNlcy5uYW1laGVyZS5idWlsZC5hcmdzLipcbiAgaWYgKC9ec2VydmljZXMjW14jXSsjYnVpbGQjYXJncyMvLnRlc3QocG91bmRQYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgbGV0IGl0IGFsbCBkZWNhbWVsaXplLlxuICByZXR1cm4gdHJ1ZTtcbn1cbiJdfQ==